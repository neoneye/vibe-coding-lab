<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Amiga Torus</title>
<style>
body { margin:0; overflow:hidden; background:#000 }
canvas { display:block }
#hud { position:absolute; top:16px; width:100%; text-align:center;
  font:bold 24px monospace; color:#fff; pointer-events:none; text-shadow:0 2px 4px #000 }
#msg { position:absolute; top:45%; width:100%; text-align:center;
  font:bold 56px monospace; pointer-events:none; opacity:0; transition:opacity 0.4s;
  text-shadow:0 0 20px currentColor }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">SPACE / click to fire! &nbsp; Score: <span id="sc">0</span></div>
<div id="msg"></div>
<script>
const canvas = document.getElementById('c'), gl = canvas.getContext('webgl');
const msgEl = document.getElementById('msg'), scEl = document.getElementById('sc');

function resize() { canvas.width=innerWidth; canvas.height=innerHeight; gl.viewport(0,0,canvas.width,canvas.height); }
addEventListener('resize', resize); resize();

// Shaders
function mkProg(vs,fs) {
    function sh(t,s){const o=gl.createShader(t);gl.shaderSource(o,s);gl.compileShader(o);return o;}
    const p=gl.createProgram(); gl.attachShader(p,sh(gl.VERTEX_SHADER,vs)); gl.attachShader(p,sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); return p;
}
const prog = mkProg(
`attribute vec3 aPos,aNorm; attribute vec2 aUV;
uniform mat4 uMV,uProj; uniform mat3 uNMat;
varying vec3 vN,vP; varying vec2 vUV;
void main(){vec4 p=uMV*vec4(aPos,1);vP=p.xyz;vN=uNMat*aNorm;vUV=aUV;gl_Position=uProj*p;}`,
`precision mediump float; varying vec3 vN,vP; varying vec2 vUV; uniform vec4 uTint;
void main(){
  vec3 b; if(uTint.a>.5){b=uTint.rgb;}
  else{float ck=mod(floor(vUV.x*10.)+floor(vUV.y*20.),2.); b=mix(vec3(.85,.05,.05),vec3(1),ck);}
  vec3 n=normalize(vN),L=normalize(vec3(.5,1,.8)),R=reflect(-L,n);
  float d=max(dot(n,L),0.),s=pow(max(dot(normalize(-vP),R),0.),32.);
  gl_FragColor=vec4(b*(.15+.75*d)+vec3(.35)*s,1.);}`);
gl.useProgram(prog);
const U=n=>gl.getUniformLocation(prog,n), A=n=>gl.getAttribLocation(prog,n);

// Geometry
function mkMesh(p,n,u,idx){
    function buf(d,t){const b=gl.createBuffer();gl.bindBuffer(t,b);gl.bufferData(t,d,gl.STATIC_DRAW);return b;}
    return{p:buf(new Float32Array(p),gl.ARRAY_BUFFER),n:buf(new Float32Array(n),gl.ARRAY_BUFFER),
        u:buf(new Float32Array(u),gl.ARRAY_BUFFER),i:buf(new Uint16Array(idx),gl.ELEMENT_ARRAY_BUFFER),c:idx.length};
}
function makeTorus(R,r,rings,segs){
    const p=[],n=[],u=[],idx=[];
    for(let i=0;i<=rings;i++){const a=(i/rings)*Math.PI*2,ca=Math.cos(a),sa=Math.sin(a);
        for(let j=0;j<=segs;j++){const v=(j/segs)*Math.PI*2,cv=Math.cos(v),sv=Math.sin(v);
            p.push((R+r*cv)*ca,(R+r*cv)*sa,r*sv); n.push(cv*ca,cv*sa,sv); u.push(i/rings,j/segs);}}
    for(let i=0;i<rings;i++)for(let j=0;j<segs;j++){const a=i*(segs+1)+j,b=a+segs+1;idx.push(a,b,a+1,b,b+1,a+1);}
    return mkMesh(p,n,u,idx);
}
function makeCube(s){
    const h=s/2,p=[],n=[],u=[],idx=[];
    [[0,0,1,[-h,-h,h],[h,-h,h],[h,h,h],[-h,h,h]],[0,0,-1,[h,-h,-h],[-h,-h,-h],[-h,h,-h],[h,h,-h]],
     [1,0,0,[h,-h,h],[h,-h,-h],[h,h,-h],[h,h,h]],[-1,0,0,[-h,-h,-h],[-h,-h,h],[-h,h,h],[-h,h,-h]],
     [0,1,0,[-h,h,h],[h,h,h],[h,h,-h],[-h,h,-h]],[0,-1,0,[-h,-h,-h],[h,-h,-h],[h,-h,h],[-h,-h,h]]
    ].forEach((f,fi)=>{const nm=[f[0],f[1],f[2]];
        for(let k=3;k<7;k++){p.push(...f[k]);n.push(...nm);u.push(0,0);}
        const b=fi*4;idx.push(b,b+1,b+2,b,b+2,b+3);});
    return mkMesh(p,n,u,idx);
}
function draw(m){
    function ba(b,at,sz){gl.bindBuffer(gl.ARRAY_BUFFER,b);const a=A(at);gl.enableVertexAttribArray(a);gl.vertexAttribPointer(a,sz,gl.FLOAT,false,0,0);}
    ba(m.p,'aPos',3);ba(m.n,'aNorm',3);ba(m.u,'aUV',2);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,m.i);gl.drawElements(gl.TRIANGLES,m.c,gl.UNSIGNED_SHORT,0);
}
const torusMesh=makeTorus(1.0,0.4,64,32), cubeMesh=makeCube(0.3);

// Matrix math (column-major)
function persp(fov,asp,n,f){const t=1/Math.tan(fov/2),nf=1/(n-f);return new Float32Array([t/asp,0,0,0,0,t,0,0,0,0,(f+n)*nf,-1,0,0,2*f*n*nf,0]);}
function mul(a,b){const o=new Float32Array(16);for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++)o[j*4+i]+=a[k*4+i]*b[j*4+k];return o;}
function rX(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([1,0,0,0,0,c,s,0,0,-s,c,0,0,0,0,1]);}
function rY(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([c,0,-s,0,0,1,0,0,s,0,c,0,0,0,0,1]);}
function rZ(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([c,s,0,0,-s,c,0,0,0,0,1,0,0,0,0,1]);}
function tr(x,y,z){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1]);}
function nm(m){return new Float32Array([m[0],m[1],m[2],m[4],m[5],m[6],m[8],m[9],m[10]]);}

// Game state
const TR=1.0, Tr=0.4, AMP=0.9, SPD=1.5, CSPD=6, CSZ=5;
let score=0, cube={active:false};

function fire(){if(!cube.active)cube={z:CSZ,y:0,vz:-CSPD,vy:0,active:true,bouncing:false,passed:false,spin:0};}
addEventListener('keydown',e=>{if(e.code==='Space'){e.preventDefault();fire();}});
canvas.addEventListener('click',fire);
canvas.addEventListener('touchstart',e=>{e.preventDefault();fire();});

function torusSDF(px,py,pz){const q=Math.sqrt(px*px+py*py)-TR;return Math.sqrt(q*q+pz*pz)-Tr;}
function showMsg(txt,col){msgEl.textContent=txt;msgEl.style.color=col;msgEl.style.opacity=1;setTimeout(()=>msgEl.style.opacity=0,900);}

// Render loop
gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE);
let prev=0;
function frame(t){
    t*=.001; const dt=Math.min(t-prev,.05); prev=t;
    const asp=canvas.width/canvas.height;
    const torusY=AMP*Math.sin(SPD*t);

    // Update cube
    if(cube.active){
        cube.z+=cube.vz*dt; cube.y+=cube.vy*dt; cube.spin+=dt*(cube.bouncing?14:5);
        if(cube.bouncing) cube.vy-=6*dt; // gravity on bounce
        if(!cube.bouncing&&!cube.passed&&Math.abs(cube.z)<Tr+0.2){
            const sdf=torusSDF(0,cube.y-torusY,cube.z);
            if(sdf<0.15){cube.bouncing=true;cube.vz=CSPD*0.6;cube.vy=(cube.y-torusY>0?1:-1)*2+Math.random()*2;showMsg('BONK!','#ff4444');}
        }
        if(!cube.bouncing&&!cube.passed&&cube.z<-(Tr+0.25)){cube.passed=true;score++;scEl.textContent=score;showMsg('SCORE!','#44ff44');}
        if(cube.z>CSZ+3||cube.z<-CSZ-3||Math.abs(cube.y)>6) cube.active=false;
    }

    // Draw
    gl.clearColor(0.0,0.2,0.4,1.0); gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    const proj=persp(Math.PI/4,asp,0.1,100);

    // Torus
    let mv=tr(0,0,-6); mv=mul(mv,tr(0,torusY,0)); mv=mul(mv,rX(0.25)); mv=mul(mv,rZ(t*0.4));
    gl.uniformMatrix4fv(U('uProj'),false,proj); gl.uniformMatrix4fv(U('uMV'),false,mv);
    gl.uniformMatrix3fv(U('uNMat'),false,nm(mv)); gl.uniform4f(U('uTint'),0,0,0,0);
    draw(torusMesh);

    // Cube
    if(cube.active){
        let cm=tr(0,0,-6); cm=mul(cm,tr(0,cube.y,cube.z)); cm=mul(cm,rX(cube.spin)); cm=mul(cm,rY(cube.spin*1.3));
        gl.uniformMatrix4fv(U('uMV'),false,cm); gl.uniformMatrix3fv(U('uNMat'),false,nm(cm));
        gl.uniform4f(U('uTint'), cube.bouncing?.9:.2, cube.bouncing?.25:.5, cube.bouncing?.1:1, 1);
        draw(cubeMesh);
    }
    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
