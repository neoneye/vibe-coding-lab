<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Amiga Torus</title>
<style>
body { margin:0; overflow:hidden; background:#000 }
canvas { display:block }
#hud { position:absolute; top:16px; width:100%; text-align:center;
  font:bold 24px monospace; color:#fff; pointer-events:none; text-shadow:0 2px 4px #000 }
#msg { position:absolute; top:42%; width:100%; text-align:center;
  font:bold 56px monospace; pointer-events:none; opacity:0; transition:opacity 0.4s;
  text-shadow:0 0 20px currentColor }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">SPACE / click to fire! &nbsp; Score: <span id="sc">0</span></div>
<div id="msg"></div>
<script>
const canvas = document.getElementById('c'), gl = canvas.getContext('webgl');
const msgEl = document.getElementById('msg'), scEl = document.getElementById('sc');
function resize() { canvas.width = innerWidth; canvas.height = innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
addEventListener('resize', resize); resize();

// Extensions
gl.getExtension('EXT_frag_depth');

// Shader helper
function mkProg(vs, fs) {
    function sh(t, s) {
        const o = gl.createShader(t); gl.shaderSource(o, s); gl.compileShader(o);
        if (!gl.getShaderParameter(o, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(o));
        return o;
    }
    const p = gl.createProgram();
    gl.attachShader(p, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
}

const MC = 32, MS = 32;

// ── Raymarching program (torus + stuck cubes + carves) ──
const rmProg = mkProg(
`attribute vec2 aPos;
varying vec2 vUV;
void main(){ vUV=aPos; gl_Position=vec4(aPos,0.999,1); }`,

`#extension GL_EXT_frag_depth : enable
precision highp float;
varying vec2 vUV;
uniform float uAsp,uTanFov;
uniform mat3 uInvRot;
const int XMC=${MC},XMS=${MS};
uniform vec3 uCarves[${MC}];
uniform int uNCrv;
uniform vec3 uStuck[${MS}];
uniform int uNStk;

float sdTorus(vec3 p){
  vec2 q=vec2(length(p.xy)-1.0,p.z);
  return length(q)-0.4;
}
float sdBox(vec3 p,vec3 b){
  vec3 d=abs(p)-b;
  return length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0);
}
float scene(vec3 p){
  float d=sdTorus(p);
  for(int i=0;i<XMS;i++){if(i>=uNStk)break; d=min(d,sdBox(p-uStuck[i],vec3(.125)));}
  for(int i=0;i<XMC;i++){if(i>=uNCrv)break; d=max(d,-sdBox(p-uCarves[i],vec3(.14)));}
  return d;
}
void main(){
  vec3 rd=normalize(vec3(vUV.x*uAsp*uTanFov,vUV.y*uTanFov,-1.0));
  float rdZ=rd.z;
  vec3 ro=vec3(0,0,7);
  vec3 lro=uInvRot*ro, lrd=uInvRot*rd;
  float b=dot(lro,lrd), c=dot(lro,lro)-6.25;
  float disc=b*b-c;
  if(disc<0.0) discard;
  float sq=sqrt(disc), tN=max(-b-sq,0.0), tF=-b+sq;
  if(tF<0.0) discard;
  float t=tN, d=1.0;
  for(int i=0;i<96;i++){
    d=scene(lro+lrd*t);
    if(d<.001||t>tF) break;
    t+=d;
  }
  if(d>.001) discard;
  vec3 p=lro+lrd*t;
  vec2 e=vec2(.001,0);
  vec3 n=normalize(vec3(
    scene(p+e.xyy)-scene(p-e.xyy),
    scene(p+e.yxy)-scene(p-e.yxy),
    scene(p+e.yyx)-scene(p-e.yyx)));
  float td=sdTorus(p);
  float sd=999.0;
  for(int i=0;i<XMS;i++){if(i>=uNStk)break; sd=min(sd,sdBox(p-uStuck[i],vec3(.125)));}
  float cd=999.0;
  for(int i=0;i<XMC;i++){if(i>=uNCrv)break; cd=min(cd,sdBox(p-uCarves[i],vec3(.14)));}
  vec3 col;
  if(cd<.01){
    col=vec3(.45,.1,.06);
  } else if(sd<td){
    col=vec3(.9,.15,.1);
  } else {
    float th=atan(p.y,p.x), ph=atan(p.z,length(p.xy)-1.0);
    float ck=mod(floor(th*1.5915+5.0)+floor(ph*3.183+10.0),2.0);
    col=mix(vec3(.85,.05,.05),vec3(1),ck);
  }
  vec3 L=uInvRot*normalize(vec3(.5,1,.8));
  vec3 V=normalize(lro-p);
  vec3 R=reflect(-L,n);
  float diff=max(dot(n,L),0.0), spec=pow(max(dot(V,R),0.0),32.0);
  gl_FragColor=vec4(col*(.15+.75*diff)+vec3(.35)*spec,1);
  float zE=rdZ*t;
  float A=-1.002, B=-0.2002;
  gl_FragDepthEXT=(A*zE+B)/(-zE)*.5+.5;
}`);

const rmU = n => gl.getUniformLocation(rmProg, n);

// ── Mesh program (flying cubes only) ──
const meshProg = mkProg(
`attribute vec3 aPos,aNorm;
uniform mat4 uMV,uProj; uniform mat3 uNMat;
varying vec3 vN,vP;
void main(){vec4 p=uMV*vec4(aPos,1);vP=p.xyz;vN=uNMat*aNorm;gl_Position=uProj*p;}`,
`precision mediump float;
varying vec3 vN,vP; uniform vec4 uTint;
void main(){
  vec3 n=normalize(vN); if(!gl_FrontFacing)n=-n;
  vec3 L=normalize(vec3(.5,1,.8)),R=reflect(-L,n);
  float d=max(dot(n,L),0.),s=pow(max(dot(normalize(-vP),R),0.),32.);
  gl_FragColor=vec4(uTint.rgb*(.15+.75*d)+vec3(.35)*s,1.);}`);

const mU = n => gl.getUniformLocation(meshProg, n);

// ── Geometry ──
// Fullscreen quad
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

// Cube mesh
function makeCube(s) {
    const h = s / 2, p = [], n = [], idx = [];
    [[0,0,1,[-h,-h,h],[h,-h,h],[h,h,h],[-h,h,h]], [0,0,-1,[h,-h,-h],[-h,-h,-h],[-h,h,-h],[h,h,-h]],
     [1,0,0,[h,-h,h],[h,-h,-h],[h,h,-h],[h,h,h]], [-1,0,0,[-h,-h,-h],[-h,-h,h],[-h,h,h],[-h,h,-h]],
     [0,1,0,[-h,h,h],[h,h,h],[h,h,-h],[-h,h,-h]], [0,-1,0,[-h,-h,-h],[h,-h,-h],[h,-h,h],[-h,-h,h]]
    ].forEach((f, fi) => { const nm = [f[0], f[1], f[2]];
        for (let k = 3; k < 7; k++) { p.push(...f[k]); n.push(...nm); }
        const b = fi * 4; idx.push(b, b + 1, b + 2, b, b + 2, b + 3); });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
const cubeMesh = makeCube(0.25);

// ── Matrix math (column-major) ──
function persp(fov, asp, n, f) { const t = 1 / Math.tan(fov / 2), nf = 1 / (n - f); return new Float32Array([t / asp,0,0,0, 0,t,0,0, 0,0,(f + n) * nf,-1, 0,0,2 * f * n * nf,0]); }
function m4(a, b) { const o = new Float32Array(16); for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) for (let k = 0; k < 4; k++) o[j*4+i] += a[k*4+i] * b[j*4+k]; return o; }
function rX(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function rY(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function tr(x, y, z) { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }
function nm3(m) { return new Float32Array([m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]); }
function xfm(m, x, y, z) { return [m[0]*x + m[4]*y + m[8]*z, m[1]*x + m[5]*y + m[9]*z, m[2]*x + m[6]*y + m[10]*z]; }

// ── Game ──
const TR = 1.0, Tr = 0.4, CUBE_H = 0.125, CSPD = 6;
let score = 0, nextType = 0;
const cubes = [], stuckCubes = [], carves = [];

function fire() {
    if (cubes.length > 50) return;
    const type = nextType; nextType = (nextType + 1) % 3;
    cubes.push({
        x: 0, y: 0, z: 6,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        vz: -CSPD,
        bouncing: false, passed: false, throughHole: false,
        type, spin: Math.random() * 6.28
    });
}
addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); fire(); } });
canvas.addEventListener('click', fire);
canvas.addEventListener('touchstart', e => { e.preventDefault(); fire(); });

function torusSDF(px, py, pz) { const q = Math.sqrt(px * px + py * py) - TR; return Math.sqrt(q * q + pz * pz) - Tr; }

function sdfNormal(x, y, z) {
    const e = 0.01;
    const gx = torusSDF(x + e, y, z) - torusSDF(x - e, y, z);
    const gy = torusSDF(x, y + e, z) - torusSDF(x, y - e, z);
    const gz = torusSDF(x, y, z + e) - torusSDF(x, y, z - e);
    const len = Math.sqrt(gx * gx + gy * gy + gz * gz) || 1;
    return [gx / len, gy / len, gz / len];
}

let msgTimer = 0;
function showMsg(txt, col) {
    msgEl.textContent = txt; msgEl.style.color = col; msgEl.style.opacity = 1;
    clearTimeout(msgTimer); msgTimer = setTimeout(() => msgEl.style.opacity = 0, 500);
}

// ── Render ──
gl.enable(gl.DEPTH_TEST);
let prev = 0;
function frame(t) {
    t *= 0.001; const dt = Math.min(t - prev, 0.05); prev = t;
    const asp = canvas.width / canvas.height;

    const tAX = t * 0.7, tAY = t * 1.1;
    const invRot = m4(rY(-tAY), rX(-tAX));
    const fwdRot = m4(rX(tAX), rY(tAY));

    // Update cubes
    for (let i = cubes.length - 1; i >= 0; i--) {
        const c = cubes[i];
        c.x += c.vx * dt; c.y += c.vy * dt; c.z += c.vz * dt;
        c.spin += dt * (c.bouncing ? 14 : 5);
        if (c.bouncing) c.vy -= 5 * dt;

        if (!c.bouncing && !c.passed) {
            const [lx, ly, lz] = xfm(invRot, c.x, c.y, c.z);
            const sdf = torusSDF(lx, ly, lz);
            const dAxis = Math.sqrt(lx * lx + ly * ly);
            if (dAxis < TR - Tr - CUBE_H && Math.abs(lz) < Tr + CUBE_H) c.throughHole = true;

            if (sdf < CUBE_H) {
                if (c.type === 0) {
                    stuckCubes.push({ lx, ly, lz, spin: c.spin });
                    if (stuckCubes.length > MS) stuckCubes.shift();
                    cubes.splice(i, 1); showMsg('STUCK!', '#ff6644'); continue;
                }
                if (c.type === 2) {
                    carves.push([lx, ly, lz]);
                    if (carves.length > MC) carves.shift();
                    for (let j = stuckCubes.length - 1; j >= 0; j--) {
                        const dx = stuckCubes[j].lx - lx, dy = stuckCubes[j].ly - ly, dz = stuckCubes[j].lz - lz;
                        if (Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz)) < 0.2) stuckCubes.splice(j, 1);
                    }
                    cubes.splice(i, 1); showMsg('CARVED!', '#4488ff'); continue;
                }
                c.bouncing = true;
                const [nx, ny, nz] = sdfNormal(lx, ly, lz);
                const [wnx, wny, wnz] = xfm(fwdRot, nx, ny, nz);
                const dot = c.vx * wnx + c.vy * wny + c.vz * wnz;
                c.vx = (c.vx - 2 * dot * wnx) * 0.5; c.vy = (c.vy - 2 * dot * wny) * 0.5; c.vz = (c.vz - 2 * dot * wnz) * 0.5;
                c.x += wnx * 0.2; c.y += wny * 0.2; c.z += wnz * 0.2;
                showMsg('BONK!', '#66ff44');
            }
        }

        if (!c.bouncing && !c.passed && c.z < -(TR + Tr + 0.5)) {
            c.passed = true;
            if (c.throughHole) { score++; scEl.textContent = score; showMsg('SCORE!', '#44ff44'); }
        }
        if (c.z > 12 || c.z < -12 || Math.abs(c.x) > 10 || Math.abs(c.y) > 10) cubes.splice(i, 1);
    }

    // Draw
    gl.clearColor(0.0, 0.2, 0.4, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const proj = persp(Math.PI / 4, asp, 0.1, 100);

    // ── Pass 1: Raymarched torus (solid CSG) ──
    gl.useProgram(rmProg);
    gl.disable(gl.CULL_FACE);
    gl.depthFunc(gl.LESS);

    gl.uniform1f(rmU('uAsp'), asp);
    gl.uniform1f(rmU('uTanFov'), Math.tan(Math.PI / 8));
    gl.uniformMatrix3fv(rmU('uInvRot'), false, nm3(invRot));

    const cd = new Float32Array(MC * 3);
    for (let i = 0; i < carves.length; i++) { cd[i*3] = carves[i][0]; cd[i*3+1] = carves[i][1]; cd[i*3+2] = carves[i][2]; }
    gl.uniform3fv(rmU('uCarves[0]'), cd);
    gl.uniform1i(rmU('uNCrv'), carves.length);

    const sd = new Float32Array(MS * 3);
    for (let i = 0; i < stuckCubes.length; i++) { sd[i*3] = stuckCubes[i].lx; sd[i*3+1] = stuckCubes[i].ly; sd[i*3+2] = stuckCubes[i].lz; }
    gl.uniform3fv(rmU('uStuck[0]'), sd);
    gl.uniform1i(rmU('uNStk'), stuckCubes.length);

    const rmAP = gl.getAttribLocation(rmProg, 'aPos');
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.enableVertexAttribArray(rmAP);
    gl.vertexAttribPointer(rmAP, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(rmAP);

    // ── Pass 2: Flying cubes (mesh) ──
    gl.useProgram(meshProg);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.uniformMatrix4fv(mU('uProj'), false, proj);

    const mAP = gl.getAttribLocation(meshProg, 'aPos');
    const mAN = gl.getAttribLocation(meshProg, 'aNorm');

    for (const c of cubes) {
        let cm = tr(0, 0, -7); cm = m4(cm, tr(c.x, c.y, c.z));
        cm = m4(cm, rX(c.spin)); cm = m4(cm, rY(c.spin * 1.3));
        gl.uniformMatrix4fv(mU('uMV'), false, cm);
        gl.uniformMatrix3fv(mU('uNMat'), false, nm3(cm));
        if (c.type === 0) gl.uniform4f(mU('uTint'), 0.9, 0.15, 0.1, 1);
        else if (c.type === 2) gl.uniform4f(mU('uTint'), 0.2, 0.4, 1.0, 1);
        else gl.uniform4f(mU('uTint'), c.bouncing ? 0.5 : 0.15, c.bouncing ? 0.9 : 0.8, 0.2, 1);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeMesh.p);
        gl.enableVertexAttribArray(mAP);
        gl.vertexAttribPointer(mAP, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeMesh.n);
        gl.enableVertexAttribArray(mAN);
        gl.vertexAttribPointer(mAN, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeMesh.i);
        gl.drawElements(gl.TRIANGLES, cubeMesh.c, gl.UNSIGNED_SHORT, 0);
    }
    gl.disableVertexAttribArray(mAP);
    gl.disableVertexAttribArray(mAN);

    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
