<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Amiga Torus</title>
<style>
body { margin:0; overflow:hidden; background:#000 }
canvas { display:block }
#hud { position:absolute; top:16px; width:100%; text-align:center;
  font:bold 24px monospace; color:#fff; pointer-events:none; text-shadow:0 2px 4px #000 }
#msg { position:absolute; top:42%; width:100%; text-align:center;
  font:bold 56px monospace; pointer-events:none; opacity:0; transition:opacity 0.4s;
  text-shadow:0 0 20px currentColor }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">SPACE / click to fire! &nbsp; Score: <span id="sc">0</span></div>
<div id="msg"></div>
<script>
const canvas = document.getElementById('c'), gl = canvas.getContext('webgl');
const msgEl = document.getElementById('msg'), scEl = document.getElementById('sc');
function resize() { canvas.width = innerWidth; canvas.height = innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
addEventListener('resize', resize); resize();

// Shaders
function mkProg(vs, fs) {
    function sh(t, s) { const o = gl.createShader(t); gl.shaderSource(o, s); gl.compileShader(o); return o; }
    const p = gl.createProgram(); gl.attachShader(p, sh(gl.VERTEX_SHADER, vs)); gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs)); gl.linkProgram(p); return p;
}
const MAX_CARVES = 32;
const prog = mkProg(
`attribute vec3 aPos,aNorm; attribute vec2 aUV;
uniform mat4 uMV,uProj; uniform mat3 uNMat;
varying vec3 vN,vP,vL; varying vec2 vUV;
void main(){vL=aPos;vec4 p=uMV*vec4(aPos,1);vP=p.xyz;vN=uNMat*aNorm;vUV=aUV;gl_Position=uProj*p;}`,
`precision mediump float; varying vec3 vN,vP,vL; varying vec2 vUV; uniform vec4 uTint;
const int MC=${MAX_CARVES}; uniform vec3 uCarves[${MAX_CARVES}]; uniform int uNCrv;
void main(){
  if(uTint.a<.75){for(int i=0;i<MC;i++){if(i>=uNCrv)break;
    vec3 d=abs(vL-uCarves[i]);if(max(d.x,max(d.y,d.z))<.13)discard;}}
  vec3 b; if(uTint.a<.1){float ck=mod(floor(vUV.x*10.)+floor(vUV.y*20.),2.);
    b=mix(vec3(.85,.05,.05),vec3(1),ck);}
  else{b=uTint.rgb;}
  vec3 n=normalize(vN); if(!gl_FrontFacing)n=-n;
  vec3 L=normalize(vec3(.5,1,.8)),R=reflect(-L,n);
  float d=max(dot(n,L),0.),s=pow(max(dot(normalize(-vP),R),0.),32.);
  gl_FragColor=vec4(b*(.15+.75*d)+vec3(.35)*s,1.);}`);
gl.useProgram(prog);
const U = n => gl.getUniformLocation(prog, n), A = n => gl.getAttribLocation(prog, n);

// Geometry
function mkMesh(p, n, u, idx) {
    function buf(d, t) { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; }
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        u: buf(new Float32Array(u), gl.ARRAY_BUFFER), i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeTorus(R, r, rings, segs) {
    const p = [], n = [], u = [], idx = [];
    for (let i = 0; i <= rings; i++) { const a = (i / rings) * Math.PI * 2, ca = Math.cos(a), sa = Math.sin(a);
        for (let j = 0; j <= segs; j++) { const v = (j / segs) * Math.PI * 2, cv = Math.cos(v), sv = Math.sin(v);
            p.push((R + r * cv) * ca, (R + r * cv) * sa, r * sv); n.push(cv * ca, cv * sa, sv); u.push(i / rings, j / segs); } }
    for (let i = 0; i < rings; i++) for (let j = 0; j < segs; j++) { const a = i * (segs + 1) + j, b = a + segs + 1; idx.push(a, b, a + 1, b, b + 1, a + 1); }
    return mkMesh(p, n, u, idx);
}
function makeCube(s) {
    const h = s / 2, p = [], n = [], u = [], idx = [];
    [[0,0,1,[-h,-h,h],[h,-h,h],[h,h,h],[-h,h,h]], [0,0,-1,[h,-h,-h],[-h,-h,-h],[-h,h,-h],[h,h,-h]],
     [1,0,0,[h,-h,h],[h,-h,-h],[h,h,-h],[h,h,h]], [-1,0,0,[-h,-h,-h],[-h,-h,h],[-h,h,h],[-h,h,-h]],
     [0,1,0,[-h,h,h],[h,h,h],[h,h,-h],[-h,h,-h]], [0,-1,0,[-h,-h,-h],[h,-h,-h],[h,-h,h],[-h,-h,h]]
    ].forEach((f, fi) => { const nm = [f[0], f[1], f[2]];
        for (let k = 3; k < 7; k++) { p.push(...f[k]); n.push(...nm); u.push(0, 0); }
        const b = fi * 4; idx.push(b, b + 1, b + 2, b, b + 2, b + 3); });
    return mkMesh(p, n, u, idx);
}
function drawMesh(m) {
    function ba(b, at, sz) { gl.bindBuffer(gl.ARRAY_BUFFER, b); const a = A(at); gl.enableVertexAttribArray(a); gl.vertexAttribPointer(a, sz, gl.FLOAT, false, 0, 0); }
    ba(m.p, 'aPos', 3); ba(m.n, 'aNorm', 3); ba(m.u, 'aUV', 2);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m.i); gl.drawElements(gl.TRIANGLES, m.c, gl.UNSIGNED_SHORT, 0);
}
const torusMesh = makeTorus(1.0, 0.4, 64, 32), cubeMesh = makeCube(0.25);

// Matrix math (column-major)
function persp(fov, asp, n, f) { const t = 1 / Math.tan(fov / 2), nf = 1 / (n - f); return new Float32Array([t / asp,0,0,0, 0,t,0,0, 0,0,(f + n) * nf,-1, 0,0,2 * f * n * nf,0]); }
function m4(a, b) { const o = new Float32Array(16); for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) for (let k = 0; k < 4; k++) o[j*4+i] += a[k*4+i] * b[j*4+k]; return o; }
function rX(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function rY(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function rZ(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1]); }
function tr(x, y, z) { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }
function nm3(m) { return new Float32Array([m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]); }
function xfm(m, x, y, z) { return [m[0]*x + m[4]*y + m[8]*z, m[1]*x + m[5]*y + m[9]*z, m[2]*x + m[6]*y + m[10]*z]; }

// Game
const TR = 1.0, Tr = 0.4, CUBE_H = 0.125, CSPD = 6;
let score = 0, nextType = 0;
const cubes = [], stuckCubes = [], carves = [];

function fire() {
    if (cubes.length > 50) return;
    const type = nextType; nextType = (nextType + 1) % 3; // 0=red(sticky), 1=green(bouncy), 2=blue(carve)
    cubes.push({
        x: 0, y: 0, z: 6,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        vz: -CSPD,
        bouncing: false, passed: false, throughHole: false,
        type, spin: Math.random() * 6.28
    });
}
addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); fire(); } });
canvas.addEventListener('click', fire);
canvas.addEventListener('touchstart', e => { e.preventDefault(); fire(); });

function torusSDF(px, py, pz) { const q = Math.sqrt(px * px + py * py) - TR; return Math.sqrt(q * q + pz * pz) - Tr; }

// SDF gradient in local space (surface normal direction)
function sdfNormal(x, y, z) {
    const e = 0.01;
    const gx = torusSDF(x + e, y, z) - torusSDF(x - e, y, z);
    const gy = torusSDF(x, y + e, z) - torusSDF(x, y - e, z);
    const gz = torusSDF(x, y, z + e) - torusSDF(x, y, z - e);
    const len = Math.sqrt(gx * gx + gy * gy + gz * gz) || 1;
    return [gx / len, gy / len, gz / len];
}

let msgTimer = 0;
function showMsg(txt, col) {
    msgEl.textContent = txt; msgEl.style.color = col; msgEl.style.opacity = 1;
    clearTimeout(msgTimer); msgTimer = setTimeout(() => msgEl.style.opacity = 0, 500);
}

// Render loop
gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE);
let prev = 0;
function frame(t) {
    t *= 0.001; const dt = Math.min(t - prev, 0.05); prev = t;
    const asp = canvas.width / canvas.height;

    // Torus rotation
    const tAX = t * 0.7, tAY = t * 1.1;
    const invRot = m4(rY(-tAY), rX(-tAX));
    const fwdRot = m4(rX(tAX), rY(tAY));

    // Update cubes
    for (let i = cubes.length - 1; i >= 0; i--) {
        const c = cubes[i];
        c.x += c.vx * dt; c.y += c.vy * dt; c.z += c.vz * dt;
        c.spin += dt * (c.bouncing ? 14 : 5);
        if (c.bouncing) c.vy -= 5 * dt;

        if (!c.bouncing && !c.passed) {
            // Transform cube position to torus-local space
            const [lx, ly, lz] = xfm(invRot, c.x, c.y, c.z);
            const sdf = torusSDF(lx, ly, lz);

            // Hole check: cube center is inside the hole cylinder in local space
            // Hole = cylinder along local Z, radius = R - r, bounded by disk thickness
            const dAxis = Math.sqrt(lx * lx + ly * ly);
            if (dAxis < TR - Tr - CUBE_H && Math.abs(lz) < Tr + CUBE_H) {
                c.throughHole = true;
            }

            // Hit check: cube surface touches torus surface
            if (sdf < CUBE_H) {
                if (c.type === 0) {
                    // Red: stick to torus surface (additive)
                    stuckCubes.push({ lx, ly, lz, spin: c.spin });
                    if (stuckCubes.length > 200) stuckCubes.shift();
                    cubes.splice(i, 1);
                    showMsg('STUCK!', '#ff6644');
                    continue;
                }
                if (c.type === 2) {
                    // Blue: carve cube-shaped hole in torus (subtractive)
                    carves.push([lx, ly, lz]);
                    if (carves.length > MAX_CARVES) carves.shift();
                    // Also remove nearby stuck cubes
                    for (let j = stuckCubes.length - 1; j >= 0; j--) {
                        const dx = stuckCubes[j].lx - lx, dy = stuckCubes[j].ly - ly, dz = stuckCubes[j].lz - lz;
                        if (Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz)) < 0.2) stuckCubes.splice(j, 1);
                    }
                    cubes.splice(i, 1);
                    showMsg('CARVED!', '#4488ff');
                    continue;
                }
                // Green: bounce off
                c.bouncing = true;
                const [nx, ny, nz] = sdfNormal(lx, ly, lz);
                const [wnx, wny, wnz] = xfm(fwdRot, nx, ny, nz);
                const dot = c.vx * wnx + c.vy * wny + c.vz * wnz;
                c.vx = (c.vx - 2 * dot * wnx) * 0.5;
                c.vy = (c.vy - 2 * dot * wny) * 0.5;
                c.vz = (c.vz - 2 * dot * wnz) * 0.5;
                c.x += wnx * 0.2; c.y += wny * 0.2; c.z += wnz * 0.2;
                showMsg('BONK!', '#66ff44');
            }
        }

        // Cube has cleared the torus
        if (!c.bouncing && !c.passed && c.z < -(TR + Tr + 0.5)) {
            c.passed = true;
            if (c.throughHole) { score++; scEl.textContent = score; showMsg('SCORE!', '#44ff44'); }
        }

        if (c.z > 12 || c.z < -12 || Math.abs(c.x) > 10 || Math.abs(c.y) > 10) cubes.splice(i, 1);
    }

    // Draw
    gl.clearColor(0.0, 0.2, 0.4, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const proj = persp(Math.PI / 4, asp, 0.1, 100);

    // Torus - set shared uniforms
    let mv = tr(0, 0, -7); mv = m4(mv, rX(tAX)); mv = m4(mv, rY(tAY));
    gl.uniformMatrix4fv(U('uProj'), false, proj);
    gl.uniformMatrix4fv(U('uMV'), false, mv);
    gl.uniformMatrix3fv(U('uNMat'), false, nm3(mv));
    const cd = new Float32Array(MAX_CARVES * 3);
    for (let i = 0; i < carves.length; i++) { cd[i*3] = carves[i][0]; cd[i*3+1] = carves[i][1]; cd[i*3+2] = carves[i][2]; }
    gl.uniform3fv(U('uCarves[0]'), cd);
    gl.uniform1i(U('uNCrv'), carves.length);
    // Pass 1: interior (back faces) - solid dark material
    gl.cullFace(gl.FRONT);
    gl.uniform4f(U('uTint'), 0.35, 0.04, 0.04, 0.3);
    drawMesh(torusMesh);
    // Pass 2: exterior (front faces) - checker pattern
    gl.cullFace(gl.BACK);
    gl.uniform4f(U('uTint'), 0, 0, 0, 0);
    drawMesh(torusMesh);

    // Stuck cubes (rotate with torus)
    for (const sc of stuckCubes) {
        let cm = tr(0, 0, -7); cm = m4(cm, rX(tAX)); cm = m4(cm, rY(tAY));
        cm = m4(cm, tr(sc.lx, sc.ly, sc.lz));
        cm = m4(cm, rX(sc.spin)); cm = m4(cm, rY(sc.spin * 0.7));
        gl.uniformMatrix4fv(U('uMV'), false, cm);
        gl.uniformMatrix3fv(U('uNMat'), false, nm3(cm));
        gl.uniform4f(U('uTint'), 0.9, 0.15, 0.1, 1);
        drawMesh(cubeMesh);
    }

    // Flying cubes
    for (const c of cubes) {
        let cm = tr(0, 0, -7); cm = m4(cm, tr(c.x, c.y, c.z));
        cm = m4(cm, rX(c.spin)); cm = m4(cm, rY(c.spin * 1.3));
        gl.uniformMatrix4fv(U('uMV'), false, cm);
        gl.uniformMatrix3fv(U('uNMat'), false, nm3(cm));
        if (c.type === 0) gl.uniform4f(U('uTint'), 0.9, 0.15, 0.1, 1);
        else if (c.type === 2) gl.uniform4f(U('uTint'), 0.2, 0.4, 1.0, 1);
        else gl.uniform4f(U('uTint'), c.bouncing ? 0.5 : 0.15, c.bouncing ? 0.9 : 0.8, 0.2, 1);
        drawMesh(cubeMesh);
    }

    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
