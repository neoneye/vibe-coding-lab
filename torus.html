<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Amiga Torus</title>
<style>
body { margin:0; overflow:hidden; background:#000 }
canvas { display:block }
#hud { position:absolute; top:16px; width:100%; text-align:center;
  font:bold 24px monospace; color:#fff; pointer-events:none; text-shadow:0 2px 4px #000 }
#msg { position:absolute; top:42%; width:100%; text-align:center;
  font:bold 56px monospace; pointer-events:none; opacity:0; transition:opacity 0.4s;
  text-shadow:0 0 20px currentColor }
#picker { position:absolute; top:52px; width:100%; text-align:center;
  font:bold 14px monospace; pointer-events:none; }
#picker span { display:inline-block; padding:4px 12px; margin:0 4px; border-radius:12px;
  cursor:pointer; pointer-events:auto; background:rgba(255,255,255,0.12);
  color:#ccc; border:2px solid transparent; transition:border-color 0.15s, color 0.15s; }
#picker span.active { border-color:#fff; color:#fff; }
#picker span[data-mode="0"] { color:#f44; }
#picker span[data-mode="0"].active { border-color:#f44; }
#picker span[data-mode="1"] { color:#4f4; }
#picker span[data-mode="1"].active { border-color:#4f4; }
#picker span[data-mode="2"] { color:#48f; }
#picker span[data-mode="2"].active { border-color:#48f; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">SPACE / click to fire! &nbsp; Score: <span id="sc">0</span> &nbsp; Next: <span id="ns">Cube</span></div>
<div id="picker">
  <span data-mode="-1" class="active">Random (1)</span>
  <span data-mode="0">Red (2)</span>
  <span data-mode="1">Green (3)</span>
  <span data-mode="2">Blue (4)</span>
</div>
<div id="msg"></div>
<script>
const canvas = document.getElementById('c'), gl = canvas.getContext('webgl');
const msgEl = document.getElementById('msg'), scEl = document.getElementById('sc'), nsEl = document.getElementById('ns');
function resize() { canvas.width = innerWidth; canvas.height = innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
addEventListener('resize', resize); resize();

// Shader helper
function mkProg(vs, fs) {
    function sh(t, s) {
        const o = gl.createShader(t); gl.shaderSource(o, s); gl.compileShader(o);
        if (!gl.getShaderParameter(o, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(o));
        return o;
    }
    const p = gl.createProgram();
    gl.attachShader(p, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
}

const MC = 32, MS = 32, MF = 16;

// ── Path-traced raymarching program ──
const rmProg = mkProg(
`attribute vec2 aPos;
varying vec2 vUV;
void main(){ vUV=aPos; gl_Position=vec4(aPos,0.999,1); }`,

`precision highp float;
varying vec2 vUV;
uniform float uAsp,uTanFov,uFrame;
uniform mat3 uInvRot;
uniform vec3 uSunDir;
const int XMC=${MC},XMS=${MS},XMF=${MF};
uniform vec4 uCarves[${MC}];
uniform int uNCrv;
uniform vec4 uStuck[${MS}];
uniform int uNStk;
uniform vec4 uFlying[${MF}];
uniform vec4 uFlyCol[${MF}];
uniform int uNFly;

// RNG
float seed;
float rng(){
  seed=fract(sin(seed*91.3458+47.9898)*43758.5453);
  return seed;
}

// Segmented torus constants
const float NMAJ=24.0, NMIN=12.0;
const float SMAJ=6.2831853/NMAJ, SMIN=6.2831853/NMIN;

// SDF primitives
float sdTorus(vec3 p){
  // Faceted major ring: snap angle to nearest segment
  float theta=atan(p.y,p.x);
  float tSnap=floor(theta/SMAJ+.5)*SMAJ;
  vec2 c=vec2(cos(tSnap),sin(tSnap));
  // Cross-section coords relative to snapped ring point
  float qx=dot(p.xy-c,c);  // radial offset from ring
  float qy=p.z;
  // Faceted minor tube: polygon cross-section
  float phi=atan(qy,qx);
  float pa=mod(phi+SMIN*.5,SMIN)-SMIN*.5;
  float dist=length(vec2(qx,qy));
  return dist*cos(pa)-0.4*cos(SMIN*.5);
}
float sdBox(vec3 p,vec3 b){
  vec3 d=abs(p)-b;
  return length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0);
}
float sdSphere(vec3 p,float r){return length(p)-r;}
float sdCylinder(vec3 p,float r,float h){
  vec2 d=vec2(length(p.xz)-r,abs(p.y)-h);
  return min(max(d.x,d.y),0.0)+length(max(d,0.0));
}
float sdTetrahedron(vec3 p,float r){
  return (max(max(p.x+p.y-p.z,p.x-p.y+p.z),max(-p.x+p.y+p.z,-p.x-p.y-p.z))/1.7321-r);
}
float sdDodecahedron(vec3 p,float r){
  vec3 n1=vec3(0,.5257,.8507),n2=vec3(0,.5257,-.8507),
       n3=vec3(.5257,.8507,0),n4=vec3(.5257,-.8507,0),
       n5=vec3(.8507,0,.5257),n6=vec3(.8507,0,-.5257);
  float d=max(max(max(abs(dot(p,n1)),abs(dot(p,n2))),max(abs(dot(p,n3)),abs(dot(p,n4)))),max(abs(dot(p,n5)),abs(dot(p,n6))));
  return d-r;
}
float sdIcosahedron(vec3 p,float r){
  float G=1.618,IP=.618,sq3=.5774;
  float d=abs(dot(p,vec3(sq3,sq3,sq3)));
  d=max(d,abs(dot(p,vec3(sq3,sq3,-sq3))));
  d=max(d,abs(dot(p,vec3(sq3,-sq3,sq3))));
  d=max(d,abs(dot(p,vec3(sq3,-sq3,-sq3))));
  d=max(d,abs(IP*p.y+G*p.z));
  d=max(d,abs(IP*p.y-G*p.z));
  d=max(d,abs(IP*p.x+G*p.z));
  d=max(d,abs(IP*p.x-G*p.z));
  d=max(d,abs(IP*p.z+G*p.x));
  d=max(d,abs(IP*p.z-G*p.x));
  return d/G-r;
}
float shapeSDF(vec3 p,float type,float sz){
  if(type<0.5) return sdBox(p,vec3(sz));
  if(type<1.5) return sdCylinder(p,sz,sz);
  if(type<2.5) return sdDodecahedron(p,sz);
  if(type<3.5) return sdSphere(p,sz);
  if(type<4.5) return sdTetrahedron(p,sz);
  if(type<5.5) return min(sdTetrahedron(p,sz),sdTetrahedron(-p,sz));
  if(type<6.5) return min(min(sdBox(p,vec3(sz,sz*.35,sz*.35)),sdBox(p,vec3(sz*.35,sz,sz*.35))),sdBox(p,vec3(sz*.35,sz*.35,sz)));
  return max(-sdIcosahedron(p,sz*.55),sdSphere(p,sz));
}

// Scene returning vec2(distance, materialID)
// matID: 0=torus, 1=stuck, 2=carved, 3+=flying
vec2 sceneFull(vec3 p){
  float td=sdTorus(p);
  float matId=0.0;
  float d=td;

  // Stuck cubes (union)
  for(int i=0;i<XMS;i++){
    if(i>=uNStk)break;
    float sd=shapeSDF(p-uStuck[i].xyz,uStuck[i].w,.125);
    if(sd<d){ d=sd; matId=1.0; }
  }

  // Carves (CSG subtraction from torus+stuck)
  for(int i=0;i<XMC;i++){
    if(i>=uNCrv)break;
    float cd=shapeSDF(p-uCarves[i].xyz,uCarves[i].w,.14);
    if(-cd>d){ d=max(d,-cd); matId=2.0; }
  }

  // Flying cubes (union)
  for(int i=0;i<XMF;i++){
    if(i>=uNFly)break;
    float fd=shapeSDF(p-uFlying[i].xyz,uFlying[i].w,.125);
    if(fd<d){ d=fd; matId=3.0+float(i); }
  }

  return vec2(d,matId);
}

float sceneD(vec3 p){ return sceneFull(p).x; }

vec3 calcNormal(vec3 p){
  vec2 e=vec2(.001,0);
  return normalize(vec3(
    sceneD(p+e.xyy)-sceneD(p-e.xyy),
    sceneD(p+e.yxy)-sceneD(p-e.yxy),
    sceneD(p+e.yyx)-sceneD(p-e.yyx)));
}

// Cosine-weighted hemisphere sample
vec3 cosHemi(vec3 n){
  float u1=rng(), u2=rng();
  float r2=sqrt(u1);
  float phi=6.2831853*u2;
  // Build tangent frame
  vec3 w=n;
  vec3 u=normalize(cross(abs(w.x)>.9?vec3(0,1,0):vec3(1,0,0),w));
  vec3 v=cross(w,u);
  return normalize(u*cos(phi)*r2 + v*sin(phi)*r2 + w*sqrt(1.0-u1));
}

// Sky environment
vec3 sky(vec3 rd){
  float sun=max(dot(rd,uSunDir),0.0);
  float horizon=exp(-max(rd.z,0.0)*3.0);
  vec3 base=mix(vec3(.15,.3,.65),vec3(.7,.5,.3),horizon);
  // Sun disc
  float sunDisc=smoothstep(.997,.999,sun);
  return base+vec3(3.0,2.7,2.0)*sunDisc+vec3(.4,.35,.2)*pow(sun,8.0);
}

// Get material color and emission for a given material ID
void getMaterial(float matId, vec3 p, out vec3 albedo, out vec3 emission){
  emission=vec3(0);
  if(matId<0.5){
    // Torus - checkerboard using segment indices
    float th=atan(p.y,p.x);
    float majSeg=floor(th/SMAJ+.5);
    float tS=majSeg*SMAJ;
    vec2 cc=vec2(cos(tS),sin(tS));
    float qx=dot(p.xy-cc,cc), qy=p.z;
    float ph=atan(qy,qx);
    float minSeg=floor(ph/SMIN+.5);
    float ck=mod(majSeg+minSeg,2.0);
    albedo=mix(vec3(.85,.05,.05),vec3(1),ck);
  } else if(matId<1.5){
    // Stuck cube - red
    albedo=vec3(.9,.15,.1);
  } else if(matId<2.5){
    // Carved surface - brown
    albedo=vec3(.45,.1,.06);
  } else {
    // Flying cube - use color from uFlyCol
    int idx=int(matId-3.0);
    // Unroll to access array with constant index (WebGL1 limitation)
    vec4 fc=uFlyCol[0];
    for(int i=0;i<XMF;i++){
      if(i==idx) fc=uFlyCol[i];
    }
    albedo=fc.rgb;
    emission=fc.rgb*fc.a;
  }
}

void main(){
  // Initialize RNG seed
  seed=fract(sin(dot(gl_FragCoord.xy+vec2(uFrame*1.73,uFrame*0.97),vec2(12.9898,78.233)))*43758.5453);
  rng(); rng(); // warm up

  vec3 rd=normalize(vec3(vUV.x*uAsp*uTanFov,vUV.y*uTanFov,-1.0));
  vec3 ro=vec3(0,0,7);
  // Transform to torus local space
  vec3 lro=uInvRot*ro, lrd=uInvRot*rd;

  vec3 col=vec3(0);
  vec3 throughput=vec3(1);

  vec3 rayO=lro, rayD=lrd;

  for(int bounce=0;bounce<3;bounce++){
    // Raymarch
    float t=0.0, d=1.0;
    vec2 hit;
    for(int i=0;i<64;i++){
      hit=sceneFull(rayO+rayD*t);
      d=hit.x;
      if(d<.001||t>20.0) break;
      t+=d;
    }

    if(d>.001||t>20.0){
      // Miss - sample sky
      col+=throughput*sky(rayD);
      break;
    }

    vec3 p=rayO+rayD*t;
    vec3 n=calcNormal(p);
    // Make sure normal faces ray
    if(dot(n,rayD)>0.0) n=-n;

    float matId=hit.y;
    vec3 albedo, emission;
    getMaterial(matId, p, albedo, emission);

    // Add emission
    col+=throughput*emission;

    // Direct light (sun shadow ray)
    vec3 shadowO=p+n*.002;
    float shadow=1.0;
    float st=0.0;
    for(int i=0;i<32;i++){
      float sd=sceneD(shadowO+uSunDir*st);
      if(sd<.001){ shadow=0.0; break; }
      if(st>20.0) break;
      st+=sd;
    }
    float ndl=max(dot(n,uSunDir),0.0);
    col+=throughput*albedo*vec3(1.5,1.4,1.2)*ndl*shadow;

    // Russian roulette after first bounce
    if(bounce>0){
      float p2=max(albedo.r,max(albedo.g,albedo.b));
      if(rng()>p2) break;
      throughput/=p2;
    }

    // Cosine-weighted bounce
    throughput*=albedo;
    rayO=p+n*.002;
    rayD=cosHemi(n);
  }

  // Tone map (Reinhard) + gamma
  col=col/(col+1.0);
  col=pow(col,vec3(1.0/2.2));
  gl_FragColor=vec4(col,1);
}`);

const rmU = n => gl.getUniformLocation(rmProg, n);

// ── Geometry ──
// Fullscreen quad
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

// ── Matrix math (column-major) ──
function m4(a, b) { const o = new Float32Array(16); for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) for (let k = 0; k < 4; k++) o[j*4+i] += a[k*4+i] * b[j*4+k]; return o; }
function rX(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function rY(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function nm3(m) { return new Float32Array([m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]); }
function xfm(m, x, y, z) { return [m[0]*x + m[4]*y + m[8]*z, m[1]*x + m[5]*y + m[9]*z, m[2]*x + m[6]*y + m[10]*z]; }

// ── Game ──
const TR = 1.0, Tr = 0.4, CUBE_H = 0.125, CSPD = 6;
let score = 0, nextType = 0, nextShape = 0, fireMode = -1;
let frameCount = 0;
const SHAPES = ['Cube','Cylinder','Dodeca','Sphere','Tetra','Stella','Cross','Gt.Icosa'];
const cubes = [], stuckCubes = [], carves = [];

function fire() {
    if (cubes.length >= MF) return;
    const type = fireMode >= 0 ? fireMode : nextType;
    if (fireMode < 0) nextType = (nextType + 1) % 3;
    const shape = nextShape; nextShape = (nextShape + 1) % 8;
    nsEl.textContent = SHAPES[nextShape];
    cubes.push({
        x: 0, y: 0, z: 6,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        vz: -CSPD,
        bouncing: false, passed: false, throughHole: false,
        type, shape, spin: Math.random() * 6.28
    });
}
function setFireMode(mode) {
    fireMode = mode;
    document.querySelectorAll('#picker span').forEach(s =>
        s.classList.toggle('active', +s.dataset.mode === mode));
}
document.querySelectorAll('#picker span').forEach(s =>
    s.addEventListener('click', () => setFireMode(+s.dataset.mode)));
addEventListener('keydown', e => {
    if (e.code === 'Space') { e.preventDefault(); fire(); }
    else if (e.key === '1') setFireMode(-1);
    else if (e.key === '2') setFireMode(0);
    else if (e.key === '3') setFireMode(1);
    else if (e.key === '4') setFireMode(2);
});
canvas.addEventListener('click', fire);
canvas.addEventListener('touchstart', e => { e.preventDefault(); fire(); });

function torusSDF(px, py, pz) { const q = Math.sqrt(px * px + py * py) - TR; return Math.sqrt(q * q + pz * pz) - Tr; }

function sdfNormal(x, y, z) {
    const e = 0.01;
    const gx = torusSDF(x + e, y, z) - torusSDF(x - e, y, z);
    const gy = torusSDF(x, y + e, z) - torusSDF(x, y - e, z);
    const gz = torusSDF(x, y, z + e) - torusSDF(x, y, z - e);
    const len = Math.sqrt(gx * gx + gy * gy + gz * gz) || 1;
    return [gx / len, gy / len, gz / len];
}

let msgTimer = 0;
function showMsg(txt, col) {
    msgEl.textContent = txt; msgEl.style.color = col; msgEl.style.opacity = 1;
    clearTimeout(msgTimer); msgTimer = setTimeout(() => msgEl.style.opacity = 0, 500);
}

// ── Render ──
let prev = 0;
function frame(t) {
    t *= 0.001; const dt = Math.min(t - prev, 0.05); prev = t;
    const asp = canvas.width / canvas.height;
    frameCount++;

    const tAX = t * 0.7, tAY = t * 1.1;
    const invRot = m4(rY(-tAY), rX(-tAX));
    const fwdRot = m4(rX(tAX), rY(tAY));

    // Update cubes
    for (let i = cubes.length - 1; i >= 0; i--) {
        const c = cubes[i];
        c.x += c.vx * dt; c.y += c.vy * dt; c.z += c.vz * dt;
        c.spin += dt * (c.bouncing ? 14 : 5);
        if (c.bouncing) c.vy -= 5 * dt;

        if (!c.bouncing && !c.passed) {
            const [lx, ly, lz] = xfm(invRot, c.x, c.y, c.z);
            const sdf = torusSDF(lx, ly, lz);
            const dAxis = Math.sqrt(lx * lx + ly * ly);
            if (dAxis < TR - Tr - CUBE_H && Math.abs(lz) < Tr + CUBE_H) c.throughHole = true;

            if (sdf < CUBE_H) {
                if (c.type === 0) {
                    stuckCubes.push({ lx, ly, lz, shape: c.shape, spin: c.spin });
                    if (stuckCubes.length > MS) stuckCubes.shift();
                    cubes.splice(i, 1); showMsg('STUCK!', '#ff6644'); continue;
                }
                if (c.type === 2) {
                    carves.push({ lx, ly, lz, shape: c.shape });
                    if (carves.length > MC) carves.shift();
                    for (let j = stuckCubes.length - 1; j >= 0; j--) {
                        const dx = stuckCubes[j].lx - lx, dy = stuckCubes[j].ly - ly, dz = stuckCubes[j].lz - lz;
                        if (Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz)) < 0.2) stuckCubes.splice(j, 1);
                    }
                    cubes.splice(i, 1); showMsg('CARVED!', '#4488ff'); continue;
                }
                c.bouncing = true;
                const [nx, ny, nz] = sdfNormal(lx, ly, lz);
                const [wnx, wny, wnz] = xfm(fwdRot, nx, ny, nz);
                const dot = c.vx * wnx + c.vy * wny + c.vz * wnz;
                c.vx = (c.vx - 2 * dot * wnx) * 0.5; c.vy = (c.vy - 2 * dot * wny) * 0.5; c.vz = (c.vz - 2 * dot * wnz) * 0.5;
                c.x += wnx * 0.2; c.y += wny * 0.2; c.z += wnz * 0.2;
                showMsg('BONK!', '#66ff44');
            }
        }

        if (!c.bouncing && !c.passed && c.z < -(TR + Tr + 0.5)) {
            c.passed = true;
            if (c.throughHole) { score++; scEl.textContent = score; showMsg('SCORE!', '#44ff44'); }
        }
        if (c.z > 12 || c.z < -12 || Math.abs(c.x) > 10 || Math.abs(c.y) > 10) cubes.splice(i, 1);
    }

    // ── Single-pass path-traced draw ──
    gl.useProgram(rmProg);

    gl.uniform1f(rmU('uAsp'), asp);
    gl.uniform1f(rmU('uTanFov'), Math.tan(Math.PI / 8));
    gl.uniform1f(rmU('uFrame'), frameCount);
    gl.uniformMatrix3fv(rmU('uInvRot'), false, nm3(invRot));

    // Sun direction in local space
    const sunWorld = [0.5, 0.8, 0.6];
    const sl = Math.sqrt(sunWorld[0]**2 + sunWorld[1]**2 + sunWorld[2]**2);
    const sunN = [sunWorld[0]/sl, sunWorld[1]/sl, sunWorld[2]/sl];
    const sunLocal = xfm(invRot, sunN[0], sunN[1], sunN[2]);
    gl.uniform3f(rmU('uSunDir'), sunLocal[0], sunLocal[1], sunLocal[2]);

    // Carves
    const cd = new Float32Array(MC * 4);
    for (let i = 0; i < carves.length; i++) { cd[i*4] = carves[i].lx; cd[i*4+1] = carves[i].ly; cd[i*4+2] = carves[i].lz; cd[i*4+3] = carves[i].shape; }
    gl.uniform4fv(rmU('uCarves[0]'), cd);
    gl.uniform1i(rmU('uNCrv'), carves.length);

    // Stuck cubes
    const sd = new Float32Array(MS * 4);
    for (let i = 0; i < stuckCubes.length; i++) { sd[i*4] = stuckCubes[i].lx; sd[i*4+1] = stuckCubes[i].ly; sd[i*4+2] = stuckCubes[i].lz; sd[i*4+3] = stuckCubes[i].shape; }
    gl.uniform4fv(rmU('uStuck[0]'), sd);
    gl.uniform1i(rmU('uNStk'), stuckCubes.length);

    // Flying cubes - transform to local space and pack
    const fd = new Float32Array(MF * 4);
    const fc = new Float32Array(MF * 4);
    const invRot3 = nm3(invRot);
    for (let i = 0; i < cubes.length && i < MF; i++) {
        const c = cubes[i];
        const lp = xfm(invRot, c.x, c.y, c.z);
        fd[i*4] = lp[0]; fd[i*4+1] = lp[1]; fd[i*4+2] = lp[2]; fd[i*4+3] = c.shape;
        // Color by type
        if (c.type === 0) { fc[i*4]=0.9; fc[i*4+1]=0.15; fc[i*4+2]=0.1; fc[i*4+3]=0.0; }
        else if (c.type === 2) { fc[i*4]=0.2; fc[i*4+1]=0.4; fc[i*4+2]=1.0; fc[i*4+3]=3.0; } // blue glow
        else { fc[i*4]=c.bouncing?0.5:0.15; fc[i*4+1]=c.bouncing?0.9:0.8; fc[i*4+2]=0.2; fc[i*4+3]=0.0; }
    }
    gl.uniform4fv(rmU('uFlying[0]'), fd);
    gl.uniform4fv(rmU('uFlyCol[0]'), fc);
    gl.uniform1i(rmU('uNFly'), Math.min(cubes.length, MF));

    // Draw fullscreen quad
    const rmAP = gl.getAttribLocation(rmProg, 'aPos');
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.enableVertexAttribArray(rmAP);
    gl.vertexAttribPointer(rmAP, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(rmAP);

    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
