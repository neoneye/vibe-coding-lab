<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Amiga Torus</title>
<style>
body { margin:0; overflow:hidden; background:#000 }
canvas { display:block }
#hud { position:absolute; top:16px; width:100%; text-align:center;
  font:bold 24px monospace; color:#fff; pointer-events:none; text-shadow:0 2px 4px #000 }
#msg { position:absolute; top:42%; width:100%; text-align:center;
  font:bold 56px monospace; pointer-events:none; opacity:0; transition:opacity 0.4s;
  text-shadow:0 0 20px currentColor }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">SPACE / click to fire! &nbsp; Score: <span id="sc">0</span> &nbsp; Next: <span id="ns">Cube</span></div>
<div id="msg"></div>
<script>
const canvas = document.getElementById('c'), gl = canvas.getContext('webgl');
const msgEl = document.getElementById('msg'), scEl = document.getElementById('sc'), nsEl = document.getElementById('ns');
function resize() { canvas.width = innerWidth; canvas.height = innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); }
addEventListener('resize', resize); resize();

// Extensions
gl.getExtension('EXT_frag_depth');

// Shader helper
function mkProg(vs, fs) {
    function sh(t, s) {
        const o = gl.createShader(t); gl.shaderSource(o, s); gl.compileShader(o);
        if (!gl.getShaderParameter(o, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(o));
        return o;
    }
    const p = gl.createProgram();
    gl.attachShader(p, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
}

const MC = 32, MS = 32;

// ── Raymarching program (torus + stuck cubes + carves) ──
const rmProg = mkProg(
`attribute vec2 aPos;
varying vec2 vUV;
void main(){ vUV=aPos; gl_Position=vec4(aPos,0.999,1); }`,

`#extension GL_EXT_frag_depth : enable
precision highp float;
varying vec2 vUV;
uniform float uAsp,uTanFov;
uniform mat3 uInvRot;
const int XMC=${MC},XMS=${MS};
uniform vec4 uCarves[${MC}];
uniform int uNCrv;
uniform vec4 uStuck[${MS}];
uniform int uNStk;

float sdTorus(vec3 p){
  vec2 q=vec2(length(p.xy)-1.0,p.z);
  return length(q)-0.4;
}
float sdBox(vec3 p,vec3 b){
  vec3 d=abs(p)-b;
  return length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0);
}
float sdSphere(vec3 p,float r){return length(p)-r;}
float sdCylinder(vec3 p,float r,float h){
  vec2 d=vec2(length(p.xz)-r,abs(p.y)-h);
  return min(max(d.x,d.y),0.0)+length(max(d,0.0));
}
float sdTetrahedron(vec3 p,float r){
  return (max(max(p.x+p.y-p.z,p.x-p.y+p.z),max(-p.x+p.y+p.z,-p.x-p.y-p.z))/1.7321-r);
}
float sdDodecahedron(vec3 p,float r){
  vec3 n1=vec3(0,.5257,.8507),n2=vec3(0,.5257,-.8507),
       n3=vec3(.5257,.8507,0),n4=vec3(.5257,-.8507,0),
       n5=vec3(.8507,0,.5257),n6=vec3(.8507,0,-.5257);
  float d=max(max(max(abs(dot(p,n1)),abs(dot(p,n2))),max(abs(dot(p,n3)),abs(dot(p,n4)))),max(abs(dot(p,n5)),abs(dot(p,n6))));
  return d-r;
}
float shapeSDF(vec3 p,float type,float sz){
  if(type<0.5) return sdBox(p,vec3(sz));
  if(type<1.5) return sdCylinder(p,sz,sz);
  if(type<2.5) return sdDodecahedron(p,sz);
  if(type<3.5) return sdSphere(p,sz);
  return sdTetrahedron(p,sz);
}
float scene(vec3 p){
  float d=sdTorus(p);
  for(int i=0;i<XMS;i++){if(i>=uNStk)break; d=min(d,shapeSDF(p-uStuck[i].xyz,uStuck[i].w,.125));}
  for(int i=0;i<XMC;i++){if(i>=uNCrv)break; d=max(d,-shapeSDF(p-uCarves[i].xyz,uCarves[i].w,.14));}
  return d;
}
void main(){
  vec3 rd=normalize(vec3(vUV.x*uAsp*uTanFov,vUV.y*uTanFov,-1.0));
  float rdZ=rd.z;
  vec3 ro=vec3(0,0,7);
  vec3 lro=uInvRot*ro, lrd=uInvRot*rd;
  float b=dot(lro,lrd), c=dot(lro,lro)-6.25;
  float disc=b*b-c;
  if(disc<0.0) discard;
  float sq=sqrt(disc), tN=max(-b-sq,0.0), tF=-b+sq;
  if(tF<0.0) discard;
  float t=tN, d=1.0;
  for(int i=0;i<96;i++){
    d=scene(lro+lrd*t);
    if(d<.001||t>tF) break;
    t+=d;
  }
  if(d>.001) discard;
  vec3 p=lro+lrd*t;
  vec2 e=vec2(.001,0);
  vec3 n=normalize(vec3(
    scene(p+e.xyy)-scene(p-e.xyy),
    scene(p+e.yxy)-scene(p-e.yxy),
    scene(p+e.yyx)-scene(p-e.yyx)));
  float td=sdTorus(p);
  float sd=999.0;
  for(int i=0;i<XMS;i++){if(i>=uNStk)break; sd=min(sd,shapeSDF(p-uStuck[i].xyz,uStuck[i].w,.125));}
  float cd=999.0;
  for(int i=0;i<XMC;i++){if(i>=uNCrv)break; cd=min(cd,shapeSDF(p-uCarves[i].xyz,uCarves[i].w,.14));}
  vec3 col;
  if(cd<.01){
    col=vec3(.45,.1,.06);
  } else if(sd<td){
    col=vec3(.9,.15,.1);
  } else {
    float th=atan(p.y,p.x), ph=atan(p.z,length(p.xy)-1.0);
    float ck=mod(floor(th*1.5915+5.0)+floor(ph*3.183+10.0),2.0);
    col=mix(vec3(.85,.05,.05),vec3(1),ck);
  }
  vec3 L=uInvRot*normalize(vec3(.5,1,.8));
  vec3 V=normalize(lro-p);
  vec3 R=reflect(-L,n);
  float diff=max(dot(n,L),0.0), spec=pow(max(dot(V,R),0.0),32.0);
  gl_FragColor=vec4(col*(.15+.75*diff)+vec3(.35)*spec,1);
  float zE=rdZ*t;
  float A=-1.002, B=-0.2002;
  gl_FragDepthEXT=(A*zE+B)/(-zE)*.5+.5;
}`);

const rmU = n => gl.getUniformLocation(rmProg, n);

// ── Mesh program (flying cubes only) ──
const meshProg = mkProg(
`attribute vec3 aPos,aNorm;
uniform mat4 uMV,uProj; uniform mat3 uNMat;
varying vec3 vN,vP;
void main(){vec4 p=uMV*vec4(aPos,1);vP=p.xyz;vN=uNMat*aNorm;gl_Position=uProj*p;}`,
`precision mediump float;
varying vec3 vN,vP; uniform vec4 uTint;
void main(){
  vec3 n=normalize(vN); if(!gl_FrontFacing)n=-n;
  vec3 L=normalize(vec3(.5,1,.8)),R=reflect(-L,n);
  float d=max(dot(n,L),0.),s=pow(max(dot(normalize(-vP),R),0.),32.);
  gl_FragColor=vec4(uTint.rgb*(.15+.75*d)+vec3(.35)*s,1.);}`);

const mU = n => gl.getUniformLocation(meshProg, n);

// ── Geometry ──
// Fullscreen quad
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

// Cube mesh
function makeCube(s) {
    const h = s / 2, p = [], n = [], idx = [];
    [[0,0,1,[-h,-h,h],[h,-h,h],[h,h,h],[-h,h,h]], [0,0,-1,[h,-h,-h],[-h,-h,-h],[-h,h,-h],[h,h,-h]],
     [1,0,0,[h,-h,h],[h,-h,-h],[h,h,-h],[h,h,h]], [-1,0,0,[-h,-h,-h],[-h,-h,h],[-h,h,h],[-h,h,-h]],
     [0,1,0,[-h,h,h],[h,h,h],[h,h,-h],[-h,h,-h]], [0,-1,0,[-h,-h,-h],[h,-h,-h],[h,-h,h],[-h,-h,h]]
    ].forEach((f, fi) => { const nm = [f[0], f[1], f[2]];
        for (let k = 3; k < 7; k++) { p.push(...f[k]); n.push(...nm); }
        const b = fi * 4; idx.push(b, b + 1, b + 2, b, b + 2, b + 3); });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeSphere(r, stacks, slices) {
    const p = [], n = [], idx = [];
    for (let i = 0; i <= stacks; i++) {
        const phi = Math.PI * i / stacks, sp = Math.sin(phi), cp = Math.cos(phi);
        for (let j = 0; j <= slices; j++) {
            const theta = 2 * Math.PI * j / slices, st = Math.sin(theta), ct = Math.cos(theta);
            const nx = sp * ct, ny = cp, nz = sp * st;
            p.push(r * nx, r * ny, r * nz); n.push(nx, ny, nz);
        }
    }
    for (let i = 0; i < stacks; i++) for (let j = 0; j < slices; j++) {
        const a = i * (slices + 1) + j, b = a + slices + 1;
        idx.push(a, b, a + 1, a + 1, b, b + 1);
    }
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeCylinder(r, hh, slices) {
    const p = [], n = [], idx = [];
    for (let i = 0; i <= 1; i++) { const y = i === 0 ? -hh : hh;
        for (let j = 0; j <= slices; j++) { const th = 2 * Math.PI * j / slices, ct = Math.cos(th), st = Math.sin(th);
            p.push(r * ct, y, r * st); n.push(ct, 0, st); } }
    for (let j = 0; j < slices; j++) { const a = j, b = j + slices + 1; idx.push(a, b, a + 1, a + 1, b, b + 1); }
    for (let cap = 0; cap < 2; cap++) { const y = cap === 0 ? -hh : hh, ny = cap === 0 ? -1 : 1, base = p.length / 3;
        p.push(0, y, 0); n.push(0, ny, 0);
        for (let j = 0; j <= slices; j++) { const th = 2 * Math.PI * j / slices;
            p.push(r * Math.cos(th), y, r * Math.sin(th)); n.push(0, ny, 0); }
        for (let j = 0; j < slices; j++) { if (cap === 0) idx.push(base, base+j+1, base+j+2);
            else idx.push(base, base+j+2, base+j+1); } }
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeTetrahedron(size) {
    const s = size * 0.55, V = [[s,s,s],[s,-s,-s],[-s,s,-s],[-s,-s,s]];
    const F = [[0,1,2],[0,2,3],[0,3,1],[1,3,2]];
    const p = [], n = [], idx = [];
    F.forEach((f, fi) => {
        const a = V[f[0]], b = V[f[1]], c = V[f[2]];
        const e1 = [b[0]-a[0],b[1]-a[1],b[2]-a[2]], e2 = [c[0]-a[0],c[1]-a[1],c[2]-a[2]];
        const nx = e1[1]*e2[2]-e1[2]*e2[1], ny = e1[2]*e2[0]-e1[0]*e2[2], nz = e1[0]*e2[1]-e1[1]*e2[0];
        const len = Math.sqrt(nx*nx+ny*ny+nz*nz)||1, nn = [nx/len,ny/len,nz/len];
        p.push(...a,...b,...c); n.push(...nn,...nn,...nn);
        const base = fi * 3; idx.push(base, base+1, base+2);
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeDodecahedron(size) {
    const phi = (1+Math.sqrt(5))/2, ip = 1/phi, s = size * 0.45;
    const V = [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1],
        [0,ip,phi],[0,ip,-phi],[0,-ip,phi],[0,-ip,-phi],[ip,phi,0],[ip,-phi,0],[-ip,phi,0],[-ip,-phi,0],
        [phi,0,ip],[phi,0,-ip],[-phi,0,ip],[-phi,0,-ip]].map(v => v.map(c => c * s));
    const F = [[0,8,10,2,16],[0,16,17,1,12],[0,12,14,4,8],[1,17,3,11,9],[1,9,5,14,12],[2,10,6,15,13],
        [2,13,3,17,16],[3,13,15,7,11],[4,14,5,19,18],[4,18,6,10,8],[5,9,11,7,19],[6,18,19,7,15]];
    const p = [], n = [], idx = [];
    F.forEach(f => {
        let cx=0,cy=0,cz=0;
        for(let k=0;k<5;k++){cx+=V[f[k]][0];cy+=V[f[k]][1];cz+=V[f[k]][2];}
        const l=Math.sqrt(cx*cx+cy*cy+cz*cz)||1, nn=[cx/l,cy/l,cz/l];
        const a=V[f[0]],b=V[f[1]],c=V[f[2]];
        const e1=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],e2=[c[0]-a[0],c[1]-a[1],c[2]-a[2]];
        const wx=e1[1]*e2[2]-e1[2]*e2[1],wy=e1[2]*e2[0]-e1[0]*e2[2],wz=e1[0]*e2[1]-e1[1]*e2[0];
        const base=p.length/3;
        for(let k=0;k<5;k++){p.push(...V[f[k]]);n.push(...nn);}
        if(wx*nn[0]+wy*nn[1]+wz*nn[2]>0) idx.push(base,base+1,base+2,base,base+2,base+3,base,base+3,base+4);
        else idx.push(base,base+2,base+1,base,base+3,base+2,base,base+4,base+3);
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
// 0=Cube, 1=Cylinder, 2=Dodecahedron, 3=Sphere, 4=Tetrahedron
const meshes = [makeCube(0.25), makeCylinder(0.1, 0.125, 16), makeDodecahedron(0.25), makeSphere(0.125, 12, 16), makeTetrahedron(0.25)];

// ── Matrix math (column-major) ──
function persp(fov, asp, n, f) { const t = 1 / Math.tan(fov / 2), nf = 1 / (n - f); return new Float32Array([t / asp,0,0,0, 0,t,0,0, 0,0,(f + n) * nf,-1, 0,0,2 * f * n * nf,0]); }
function m4(a, b) { const o = new Float32Array(16); for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) for (let k = 0; k < 4; k++) o[j*4+i] += a[k*4+i] * b[j*4+k]; return o; }
function rX(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function rY(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function tr(x, y, z) { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }
function nm3(m) { return new Float32Array([m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]); }
function xfm(m, x, y, z) { return [m[0]*x + m[4]*y + m[8]*z, m[1]*x + m[5]*y + m[9]*z, m[2]*x + m[6]*y + m[10]*z]; }

// ── Game ──
const TR = 1.0, Tr = 0.4, CUBE_H = 0.125, CSPD = 6;
let score = 0, nextType = 0, nextShape = 0;
const SHAPES = ['Cube','Cylinder','Dodeca','Sphere','Tetra'];
const cubes = [], stuckCubes = [], carves = [];

function fire() {
    if (cubes.length > 50) return;
    const type = nextType; nextType = (nextType + 1) % 3;
    const shape = nextShape; nextShape = (nextShape + 1) % 5;
    nsEl.textContent = SHAPES[nextShape];
    cubes.push({
        x: 0, y: 0, z: 6,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        vz: -CSPD,
        bouncing: false, passed: false, throughHole: false,
        type, shape, spin: Math.random() * 6.28
    });
}
addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); fire(); } });
canvas.addEventListener('click', fire);
canvas.addEventListener('touchstart', e => { e.preventDefault(); fire(); });

function torusSDF(px, py, pz) { const q = Math.sqrt(px * px + py * py) - TR; return Math.sqrt(q * q + pz * pz) - Tr; }

function sdfNormal(x, y, z) {
    const e = 0.01;
    const gx = torusSDF(x + e, y, z) - torusSDF(x - e, y, z);
    const gy = torusSDF(x, y + e, z) - torusSDF(x, y - e, z);
    const gz = torusSDF(x, y, z + e) - torusSDF(x, y, z - e);
    const len = Math.sqrt(gx * gx + gy * gy + gz * gz) || 1;
    return [gx / len, gy / len, gz / len];
}

let msgTimer = 0;
function showMsg(txt, col) {
    msgEl.textContent = txt; msgEl.style.color = col; msgEl.style.opacity = 1;
    clearTimeout(msgTimer); msgTimer = setTimeout(() => msgEl.style.opacity = 0, 500);
}

// ── Render ──
gl.enable(gl.DEPTH_TEST);
let prev = 0;
function frame(t) {
    t *= 0.001; const dt = Math.min(t - prev, 0.05); prev = t;
    const asp = canvas.width / canvas.height;

    const tAX = t * 0.7, tAY = t * 1.1;
    const invRot = m4(rY(-tAY), rX(-tAX));
    const fwdRot = m4(rX(tAX), rY(tAY));

    // Update cubes
    for (let i = cubes.length - 1; i >= 0; i--) {
        const c = cubes[i];
        c.x += c.vx * dt; c.y += c.vy * dt; c.z += c.vz * dt;
        c.spin += dt * (c.bouncing ? 14 : 5);
        if (c.bouncing) c.vy -= 5 * dt;

        if (!c.bouncing && !c.passed) {
            const [lx, ly, lz] = xfm(invRot, c.x, c.y, c.z);
            const sdf = torusSDF(lx, ly, lz);
            const dAxis = Math.sqrt(lx * lx + ly * ly);
            if (dAxis < TR - Tr - CUBE_H && Math.abs(lz) < Tr + CUBE_H) c.throughHole = true;

            if (sdf < CUBE_H) {
                if (c.type === 0) {
                    stuckCubes.push({ lx, ly, lz, shape: c.shape, spin: c.spin });
                    if (stuckCubes.length > MS) stuckCubes.shift();
                    cubes.splice(i, 1); showMsg('STUCK!', '#ff6644'); continue;
                }
                if (c.type === 2) {
                    carves.push({ lx, ly, lz, shape: c.shape });
                    if (carves.length > MC) carves.shift();
                    for (let j = stuckCubes.length - 1; j >= 0; j--) {
                        const dx = stuckCubes[j].lx - lx, dy = stuckCubes[j].ly - ly, dz = stuckCubes[j].lz - lz;
                        if (Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz)) < 0.2) stuckCubes.splice(j, 1);
                    }
                    cubes.splice(i, 1); showMsg('CARVED!', '#4488ff'); continue;
                }
                c.bouncing = true;
                const [nx, ny, nz] = sdfNormal(lx, ly, lz);
                const [wnx, wny, wnz] = xfm(fwdRot, nx, ny, nz);
                const dot = c.vx * wnx + c.vy * wny + c.vz * wnz;
                c.vx = (c.vx - 2 * dot * wnx) * 0.5; c.vy = (c.vy - 2 * dot * wny) * 0.5; c.vz = (c.vz - 2 * dot * wnz) * 0.5;
                c.x += wnx * 0.2; c.y += wny * 0.2; c.z += wnz * 0.2;
                showMsg('BONK!', '#66ff44');
            }
        }

        if (!c.bouncing && !c.passed && c.z < -(TR + Tr + 0.5)) {
            c.passed = true;
            if (c.throughHole) { score++; scEl.textContent = score; showMsg('SCORE!', '#44ff44'); }
        }
        if (c.z > 12 || c.z < -12 || Math.abs(c.x) > 10 || Math.abs(c.y) > 10) cubes.splice(i, 1);
    }

    // Draw
    gl.clearColor(0.0, 0.2, 0.4, 1.0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const proj = persp(Math.PI / 4, asp, 0.1, 100);

    // ── Pass 1: Raymarched torus (solid CSG) ──
    gl.useProgram(rmProg);
    gl.disable(gl.CULL_FACE);
    gl.depthFunc(gl.LESS);

    gl.uniform1f(rmU('uAsp'), asp);
    gl.uniform1f(rmU('uTanFov'), Math.tan(Math.PI / 8));
    gl.uniformMatrix3fv(rmU('uInvRot'), false, nm3(invRot));

    const cd = new Float32Array(MC * 4);
    for (let i = 0; i < carves.length; i++) { cd[i*4] = carves[i].lx; cd[i*4+1] = carves[i].ly; cd[i*4+2] = carves[i].lz; cd[i*4+3] = carves[i].shape; }
    gl.uniform4fv(rmU('uCarves[0]'), cd);
    gl.uniform1i(rmU('uNCrv'), carves.length);

    const sd = new Float32Array(MS * 4);
    for (let i = 0; i < stuckCubes.length; i++) { sd[i*4] = stuckCubes[i].lx; sd[i*4+1] = stuckCubes[i].ly; sd[i*4+2] = stuckCubes[i].lz; sd[i*4+3] = stuckCubes[i].shape; }
    gl.uniform4fv(rmU('uStuck[0]'), sd);
    gl.uniform1i(rmU('uNStk'), stuckCubes.length);

    const rmAP = gl.getAttribLocation(rmProg, 'aPos');
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.enableVertexAttribArray(rmAP);
    gl.vertexAttribPointer(rmAP, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(rmAP);

    // ── Pass 2: Flying cubes (mesh) ──
    gl.useProgram(meshProg);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.uniformMatrix4fv(mU('uProj'), false, proj);

    const mAP = gl.getAttribLocation(meshProg, 'aPos');
    const mAN = gl.getAttribLocation(meshProg, 'aNorm');

    for (const c of cubes) {
        let cm = tr(0, 0, -7); cm = m4(cm, tr(c.x, c.y, c.z));
        cm = m4(cm, rX(c.spin)); cm = m4(cm, rY(c.spin * 1.3));
        gl.uniformMatrix4fv(mU('uMV'), false, cm);
        gl.uniformMatrix3fv(mU('uNMat'), false, nm3(cm));
        if (c.type === 0) gl.uniform4f(mU('uTint'), 0.9, 0.15, 0.1, 1);
        else if (c.type === 2) gl.uniform4f(mU('uTint'), 0.2, 0.4, 1.0, 1);
        else gl.uniform4f(mU('uTint'), c.bouncing ? 0.5 : 0.15, c.bouncing ? 0.9 : 0.8, 0.2, 1);

        const mesh = meshes[c.shape];
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.p);
        gl.enableVertexAttribArray(mAP);
        gl.vertexAttribPointer(mAP, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.n);
        gl.enableVertexAttribArray(mAN);
        gl.vertexAttribPointer(mAN, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.i);
        gl.drawElements(gl.TRIANGLES, mesh.c, gl.UNSIGNED_SHORT, 0);
    }
    gl.disableVertexAttribArray(mAP);
    gl.disableVertexAttribArray(mAN);

    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
