<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Amiga Torus</title>
<style>
body { margin:0; overflow:hidden; background:#000 }
canvas { display:block }
#hud { position:absolute; top:16px; width:100%; text-align:center;
  font:bold 24px monospace; color:#fff; pointer-events:none; text-shadow:0 2px 4px #000 }
#msg { position:absolute; top:42%; width:100%; text-align:center;
  font:bold 56px monospace; pointer-events:none; opacity:0; transition:opacity 0.4s;
  text-shadow:0 0 20px currentColor }
#picker { position:absolute; top:52px; width:100%; text-align:center;
  font:bold 14px monospace; pointer-events:none; }
#picker span { display:inline-block; padding:4px 12px; margin:0 4px; border-radius:12px;
  cursor:pointer; pointer-events:auto; background:rgba(255,255,255,0.12);
  color:#ccc; border:2px solid transparent; transition:border-color 0.15s, color 0.15s; }
#picker span.active { border-color:#fff; color:#fff; }
#picker span[data-mode="0"] { color:#f44; }
#picker span[data-mode="0"].active { border-color:#f44; }
#picker span[data-mode="1"] { color:#4f4; }
#picker span[data-mode="1"].active { border-color:#4f4; }
#picker span[data-mode="2"] { color:#48f; }
#picker span[data-mode="2"].active { border-color:#48f; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">SPACE / click to fire! &nbsp; Score: <span id="sc">0</span> &nbsp; Next: <span id="ns">Cube</span></div>
<div id="picker">
  <span data-mode="-1" class="active">Random (1)</span>
  <span data-mode="0">Red (2)</span>
  <span data-mode="1">Green (3)</span>
  <span data-mode="2">Blue (4)</span>
</div>
<div id="msg"></div>
<script>
const canvas = document.getElementById('c'), gl = canvas.getContext('webgl');
const msgEl = document.getElementById('msg'), scEl = document.getElementById('sc'), nsEl = document.getElementById('ns');
function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize); resize();

// Extensions
gl.getExtension('EXT_frag_depth');

// Shader helper
function mkProg(vs, fs) {
    function sh(t, s) {
        const o = gl.createShader(t); gl.shaderSource(o, s); gl.compileShader(o);
        if (!gl.getShaderParameter(o, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(o));
        return o;
    }
    const p = gl.createProgram();
    gl.attachShader(p, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
}

const MC = 32, MS = 32;

// ── Raymarching program (torus + stuck cubes + carves) ──
const rmProg = mkProg(
`attribute vec2 aPos;
varying vec2 vUV;
void main(){ vUV=aPos; gl_Position=vec4(aPos,0.999,1); }`,

`#extension GL_EXT_frag_depth : enable
precision highp float;
varying vec2 vUV;
uniform float uAsp,uTanFov;
uniform mat3 uInvRot;
uniform vec3 uCamPos;
uniform mat3 uCamMat;
const int XMC=${MC},XMS=${MS};
uniform vec4 uCarves[${MC}];
uniform int uNCrv;
uniform vec4 uStuck[${MS}];
uniform int uNStk;

const float NMAJ=24.0, NMIN=12.0;
const float SMAJ=6.2831853/NMAJ, SMIN=6.2831853/NMIN;
float sdTorus(vec3 p){
  float theta=atan(p.y,p.x);
  float tSnap=floor(theta/SMAJ+.5)*SMAJ;
  vec2 c=vec2(cos(tSnap),sin(tSnap));
  float qx=dot(p.xy-c,c);
  float qy=p.z;
  float phi=atan(qy,qx);
  float pa=mod(phi+SMIN*.5,SMIN)-SMIN*.5;
  float dist=length(vec2(qx,qy));
  return dist*cos(pa)-0.4*cos(SMIN*.5);
}
float sdBox(vec3 p,vec3 b){
  vec3 d=abs(p)-b;
  return length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0);
}
float sdSphere(vec3 p,float r){return length(p)-r;}
float sdCylinder(vec3 p,float r,float h){
  vec2 d=vec2(length(p.xz)-r,abs(p.y)-h);
  return min(max(d.x,d.y),0.0)+length(max(d,0.0));
}
float sdTetrahedron(vec3 p,float r){
  return (max(max(p.x+p.y-p.z,p.x-p.y+p.z),max(-p.x+p.y+p.z,-p.x-p.y-p.z))/1.7321-r);
}
float sdDodecahedron(vec3 p,float r){
  vec3 n1=vec3(0,.5257,.8507),n2=vec3(0,.5257,-.8507),
       n3=vec3(.5257,.8507,0),n4=vec3(.5257,-.8507,0),
       n5=vec3(.8507,0,.5257),n6=vec3(.8507,0,-.5257);
  float d=max(max(max(abs(dot(p,n1)),abs(dot(p,n2))),max(abs(dot(p,n3)),abs(dot(p,n4)))),max(abs(dot(p,n5)),abs(dot(p,n6))));
  return d-r;
}
float sdIcosahedron(vec3 p,float r){
  float G=1.618,IP=.618,sq3=.5774;
  float d=abs(dot(p,vec3(sq3,sq3,sq3)));
  d=max(d,abs(dot(p,vec3(sq3,sq3,-sq3))));
  d=max(d,abs(dot(p,vec3(sq3,-sq3,sq3))));
  d=max(d,abs(dot(p,vec3(sq3,-sq3,-sq3))));
  d=max(d,abs(IP*p.y+G*p.z));
  d=max(d,abs(IP*p.y-G*p.z));
  d=max(d,abs(IP*p.x+G*p.z));
  d=max(d,abs(IP*p.x-G*p.z));
  d=max(d,abs(IP*p.z+G*p.x));
  d=max(d,abs(IP*p.z-G*p.x));
  return d/G-r;
}
float shapeSDF(vec3 p,float type,float sz){
  if(type<0.5) return sdBox(p,vec3(sz));
  if(type<1.5) return sdCylinder(p,sz,sz);
  if(type<2.5) return sdDodecahedron(p,sz);
  if(type<3.5) return sdSphere(p,sz);
  if(type<4.5) return sdTetrahedron(p,sz);
  if(type<5.5) return min(sdTetrahedron(p,sz),sdTetrahedron(-p,sz));
  if(type<6.5) return min(min(sdBox(p,vec3(sz,sz*.35,sz*.35)),sdBox(p,vec3(sz*.35,sz,sz*.35))),sdBox(p,vec3(sz*.35,sz*.35,sz)));
  return max(-sdIcosahedron(p,sz*.55),sdSphere(p,sz));
}
float scene(vec3 p){
  float d=sdTorus(p);
  for(int i=0;i<XMS;i++){if(i>=uNStk)break; d=min(d,shapeSDF(p-uStuck[i].xyz,uStuck[i].w,.125));}
  for(int i=0;i<XMC;i++){if(i>=uNCrv)break; d=max(d,-shapeSDF(p-uCarves[i].xyz,uCarves[i].w,.14));}
  return d;
}
void main(){
  vec3 rd=normalize(vec3(vUV.x*uAsp*uTanFov,vUV.y*uTanFov,-1.0));
  float rdZ=rd.z;
  vec3 lro=uCamPos, lrd=uCamMat*rd;
  float b=dot(lro,lrd), c=dot(lro,lro)-6.25;
  float disc=b*b-c;
  if(disc<0.0){gl_FragColor=vec4(0.0,0.2,0.4,1.0);return;}
  float sq=sqrt(disc), tN=max(-b-sq,0.0), tF=-b+sq;
  if(tF<0.0){gl_FragColor=vec4(0.0,0.2,0.4,1.0);return;}
  float t=tN, d=1.0;
  for(int i=0;i<96;i++){
    d=scene(lro+lrd*t);
    if(d<.001||t>tF) break;
    t+=d;
  }
  if(d>.001){gl_FragColor=vec4(0.0,0.2,0.4,1.0);return;}
  vec3 p=lro+lrd*t;
  vec2 e=vec2(.001,0);
  vec3 n=normalize(vec3(
    scene(p+e.xyy)-scene(p-e.xyy),
    scene(p+e.yxy)-scene(p-e.yxy),
    scene(p+e.yyx)-scene(p-e.yyx)));
  float td=sdTorus(p);
  float sd=999.0;
  for(int i=0;i<XMS;i++){if(i>=uNStk)break; sd=min(sd,shapeSDF(p-uStuck[i].xyz,uStuck[i].w,.125));}
  float cd=999.0;
  for(int i=0;i<XMC;i++){if(i>=uNCrv)break; cd=min(cd,shapeSDF(p-uCarves[i].xyz,uCarves[i].w,.14));}
  vec3 col;
  if(cd<.01){
    col=vec3(.45,.1,.06);
  } else if(sd<td){
    col=vec3(.9,.15,.1);
  } else {
    float th=atan(p.y,p.x);
    float majSeg=floor(th/SMAJ+.5);
    float tS=majSeg*SMAJ;
    vec2 cc=vec2(cos(tS),sin(tS));
    float qx=dot(p.xy-cc,cc), qy=p.z;
    float ph=atan(qy,qx);
    float minSeg=floor(ph/SMIN+.5);
    float ck=mod(majSeg+minSeg,2.0);
    col=mix(vec3(.85,.05,.05),vec3(1),ck);
  }
  vec3 L=uInvRot*normalize(vec3(.5,1,.8));
  vec3 V=normalize(lro-p);
  vec3 R=reflect(-L,n);
  float diff=max(dot(n,L),0.0), spec=pow(max(dot(V,R),0.0),32.0);
  gl_FragColor=vec4(col*(.15+.75*diff)+vec3(.35)*spec,1);
  float zE=rdZ*t;
  float A=-1.002, B=-0.2002;
  gl_FragDepthEXT=(A*zE+B)/(-zE)*.5+.5;
}`);

const rmU = n => gl.getUniformLocation(rmProg, n);

// ── Mesh program (flying cubes only) ──
const meshProg = mkProg(
`attribute vec3 aPos,aNorm;
uniform mat4 uMV,uProj; uniform mat3 uNMat;
varying vec3 vN,vP;
void main(){vec4 p=uMV*vec4(aPos,1);vP=p.xyz;vN=uNMat*aNorm;gl_Position=uProj*p;}`,
`precision mediump float;
varying vec3 vN,vP; uniform vec4 uTint;
void main(){
  vec3 n=normalize(vN); if(!gl_FrontFacing)n=-n;
  vec3 L=normalize(vec3(.5,1,.8)),R=reflect(-L,n);
  float d=max(dot(n,L),0.),s=pow(max(dot(normalize(-vP),R),0.),32.);
  gl_FragColor=vec4(uTint.rgb*(.15+.75*d)+vec3(.35)*s,1.);}`);

const mU = n => gl.getUniformLocation(meshProg, n);

// ── Geometry ──
// Fullscreen quad
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

// Cube mesh
function makeCube(s) {
    const h = s / 2, p = [], n = [], idx = [];
    [[0,0,1,[-h,-h,h],[h,-h,h],[h,h,h],[-h,h,h]], [0,0,-1,[h,-h,-h],[-h,-h,-h],[-h,h,-h],[h,h,-h]],
     [1,0,0,[h,-h,h],[h,-h,-h],[h,h,-h],[h,h,h]], [-1,0,0,[-h,-h,-h],[-h,-h,h],[-h,h,h],[-h,h,-h]],
     [0,1,0,[-h,h,h],[h,h,h],[h,h,-h],[-h,h,-h]], [0,-1,0,[-h,-h,-h],[h,-h,-h],[h,-h,h],[-h,-h,h]]
    ].forEach((f, fi) => { const nm = [f[0], f[1], f[2]];
        for (let k = 3; k < 7; k++) { p.push(...f[k]); n.push(...nm); }
        const b = fi * 4; idx.push(b, b + 1, b + 2, b, b + 2, b + 3); });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeSphere(r, stacks, slices) {
    const p = [], n = [], idx = [];
    for (let i = 0; i <= stacks; i++) {
        const phi = Math.PI * i / stacks, sp = Math.sin(phi), cp = Math.cos(phi);
        for (let j = 0; j <= slices; j++) {
            const theta = 2 * Math.PI * j / slices, st = Math.sin(theta), ct = Math.cos(theta);
            const nx = sp * ct, ny = cp, nz = sp * st;
            p.push(r * nx, r * ny, r * nz); n.push(nx, ny, nz);
        }
    }
    for (let i = 0; i < stacks; i++) for (let j = 0; j < slices; j++) {
        const a = i * (slices + 1) + j, b = a + slices + 1;
        idx.push(a, b, a + 1, a + 1, b, b + 1);
    }
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeCylinder(r, hh, slices) {
    const p = [], n = [], idx = [];
    for (let i = 0; i <= 1; i++) { const y = i === 0 ? -hh : hh;
        for (let j = 0; j <= slices; j++) { const th = 2 * Math.PI * j / slices, ct = Math.cos(th), st = Math.sin(th);
            p.push(r * ct, y, r * st); n.push(ct, 0, st); } }
    for (let j = 0; j < slices; j++) { const a = j, b = j + slices + 1; idx.push(a, b, a + 1, a + 1, b, b + 1); }
    for (let cap = 0; cap < 2; cap++) { const y = cap === 0 ? -hh : hh, ny = cap === 0 ? -1 : 1, base = p.length / 3;
        p.push(0, y, 0); n.push(0, ny, 0);
        for (let j = 0; j <= slices; j++) { const th = 2 * Math.PI * j / slices;
            p.push(r * Math.cos(th), y, r * Math.sin(th)); n.push(0, ny, 0); }
        for (let j = 0; j < slices; j++) { if (cap === 0) idx.push(base, base+j+1, base+j+2);
            else idx.push(base, base+j+2, base+j+1); } }
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeTetrahedron(size) {
    const s = size * 0.55, V = [[s,s,s],[s,-s,-s],[-s,s,-s],[-s,-s,s]];
    const F = [[0,1,2],[0,2,3],[0,3,1],[1,3,2]];
    const p = [], n = [], idx = [];
    F.forEach((f, fi) => {
        const a = V[f[0]], b = V[f[1]], c = V[f[2]];
        const e1 = [b[0]-a[0],b[1]-a[1],b[2]-a[2]], e2 = [c[0]-a[0],c[1]-a[1],c[2]-a[2]];
        const nx = e1[1]*e2[2]-e1[2]*e2[1], ny = e1[2]*e2[0]-e1[0]*e2[2], nz = e1[0]*e2[1]-e1[1]*e2[0];
        const len = Math.sqrt(nx*nx+ny*ny+nz*nz)||1, nn = [nx/len,ny/len,nz/len];
        p.push(...a,...b,...c); n.push(...nn,...nn,...nn);
        const base = fi * 3; idx.push(base, base+1, base+2);
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeDodecahedron(size) {
    const phi = (1+Math.sqrt(5))/2, ip = 1/phi, s = size * 0.45;
    const V = [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1],
        [0,ip,phi],[0,ip,-phi],[0,-ip,phi],[0,-ip,-phi],[ip,phi,0],[ip,-phi,0],[-ip,phi,0],[-ip,-phi,0],
        [phi,0,ip],[phi,0,-ip],[-phi,0,ip],[-phi,0,-ip]].map(v => v.map(c => c * s));
    const F = [[0,8,10,2,16],[0,16,17,1,12],[0,12,14,4,8],[1,17,3,11,9],[1,9,5,14,12],[2,10,6,15,13],
        [2,13,3,17,16],[3,13,15,7,11],[4,14,5,19,18],[4,18,6,10,8],[5,9,11,7,19],[6,18,19,7,15]];
    const p = [], n = [], idx = [];
    F.forEach(f => {
        let cx=0,cy=0,cz=0;
        for(let k=0;k<5;k++){cx+=V[f[k]][0];cy+=V[f[k]][1];cz+=V[f[k]][2];}
        const l=Math.sqrt(cx*cx+cy*cy+cz*cz)||1, nn=[cx/l,cy/l,cz/l];
        const a=V[f[0]],b=V[f[1]],c=V[f[2]];
        const e1=[b[0]-a[0],b[1]-a[1],b[2]-a[2]],e2=[c[0]-a[0],c[1]-a[1],c[2]-a[2]];
        const wx=e1[1]*e2[2]-e1[2]*e2[1],wy=e1[2]*e2[0]-e1[0]*e2[2],wz=e1[0]*e2[1]-e1[1]*e2[0];
        const base=p.length/3;
        for(let k=0;k<5;k++){p.push(...V[f[k]]);n.push(...nn);}
        if(wx*nn[0]+wy*nn[1]+wz*nn[2]>0) idx.push(base,base+1,base+2,base,base+2,base+3,base,base+3,base+4);
        else idx.push(base,base+2,base+1,base,base+3,base+2,base,base+4,base+3);
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeStellatedOcta(size) {
    const s = size * 0.55, V1 = [[s,s,s],[s,-s,-s],[-s,s,-s],[-s,-s,s]];
    const V2 = V1.map(v => [-v[0], -v[1], -v[2]]);
    const F = [[0,1,2],[0,2,3],[0,3,1],[1,3,2]];
    const p = [], n = [], idx = [];
    [V1, V2].forEach(V => {
        F.forEach(f => {
            const a = V[f[0]], b = V[f[1]], c = V[f[2]];
            const e1 = [b[0]-a[0],b[1]-a[1],b[2]-a[2]], e2 = [c[0]-a[0],c[1]-a[1],c[2]-a[2]];
            const nx = e1[1]*e2[2]-e1[2]*e2[1], ny = e1[2]*e2[0]-e1[0]*e2[2], nz = e1[0]*e2[1]-e1[1]*e2[0];
            const len = Math.sqrt(nx*nx+ny*ny+nz*nz)||1, nn = [nx/len,ny/len,nz/len];
            const base = p.length / 3;
            p.push(...a,...b,...c); n.push(...nn,...nn,...nn);
            idx.push(base, base+1, base+2);
        });
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeCross(size) {
    const h = size / 2, t = h * 0.35, p = [], n = [], idx = [];
    const boxes = [[h,t,t],[t,h,t],[t,t,h]];
    boxes.forEach(([bx,by,bz]) => {
        [[0,0,1,[-bx,-by,bz],[bx,-by,bz],[bx,by,bz],[-bx,by,bz]],
         [0,0,-1,[bx,-by,-bz],[-bx,-by,-bz],[-bx,by,-bz],[bx,by,-bz]],
         [1,0,0,[bx,-by,bz],[bx,-by,-bz],[bx,by,-bz],[bx,by,bz]],
         [-1,0,0,[-bx,-by,-bz],[-bx,-by,bz],[-bx,by,bz],[-bx,by,-bz]],
         [0,1,0,[-bx,by,bz],[bx,by,bz],[bx,by,-bz],[-bx,by,-bz]],
         [0,-1,0,[-bx,-by,-bz],[bx,-by,-bz],[bx,-by,bz],[-bx,-by,bz]]
        ].forEach(f => {
            const nm = [f[0], f[1], f[2]], base = p.length / 3;
            for (let k = 3; k < 7; k++) { p.push(...f[k]); n.push(...nm); }
            idx.push(base, base+1, base+2, base, base+2, base+3);
        });
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
function makeGreatIcosa(size) {
    const phi = (1+Math.sqrt(5))/2, r = size * 0.5;
    // 12 icosahedron vertices
    const raw = [];
    for (let s1 = -1; s1 <= 1; s1 += 2) for (let s2 = -1; s2 <= 1; s2 += 2) {
        raw.push([0, s1, s2*phi]);
        raw.push([s1, s2*phi, 0]);
        raw.push([s2*phi, 0, s1]);
    }
    // normalize to radius r
    const V = raw.map(v => { const l = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/l*r, v[1]/l*r, v[2]/l*r]; });
    // find 20 triangular faces by finding triplets where all 3 pairs are nearest neighbors
    const dist2 = (a,b) => (a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2;
    const edgeLen2 = dist2(V[0], V[1]) * 1.1; // threshold
    // find minimum edge distance first
    let minD = Infinity;
    for (let i = 0; i < 12; i++) for (let j = i+1; j < 12; j++) { const d = dist2(V[i],V[j]); if (d < minD) minD = d; }
    const thresh = minD * 1.5;
    const faces = [];
    for (let i = 0; i < 12; i++) for (let j = i+1; j < 12; j++) for (let k = j+1; k < 12; k++) {
        if (dist2(V[i],V[j]) < thresh && dist2(V[j],V[k]) < thresh && dist2(V[i],V[k]) < thresh)
            faces.push([i,j,k]);
    }
    // Create triakis icosahedron: for each face, push center outward as spike
    const spikeR = r * 1.3;
    const p = [], n = [], idx = [];
    faces.forEach(f => {
        const a = V[f[0]], b = V[f[1]], c = V[f[2]];
        const cx = (a[0]+b[0]+c[0])/3, cy = (a[1]+b[1]+c[1])/3, cz = (a[2]+b[2]+c[2])/3;
        const cl = Math.sqrt(cx*cx+cy*cy+cz*cz)||1;
        const tip = [cx/cl*spikeR, cy/cl*spikeR, cz/cl*spikeR];
        // 3 sub-triangles: tip-a-b, tip-b-c, tip-c-a
        [[tip,a,b],[tip,b,c],[tip,c,a]].forEach(tri => {
            const e1 = [tri[1][0]-tri[0][0],tri[1][1]-tri[0][1],tri[1][2]-tri[0][2]];
            const e2 = [tri[2][0]-tri[0][0],tri[2][1]-tri[0][1],tri[2][2]-tri[0][2]];
            const nx = e1[1]*e2[2]-e1[2]*e2[1], ny = e1[2]*e2[0]-e1[0]*e2[2], nz = e1[0]*e2[1]-e1[1]*e2[0];
            const len = Math.sqrt(nx*nx+ny*ny+nz*nz)||1;
            // orient normal outward (dot with centroid)
            const fcx = (tri[0][0]+tri[1][0]+tri[2][0])/3, fcy = (tri[0][1]+tri[1][1]+tri[2][1])/3, fcz = (tri[0][2]+tri[1][2]+tri[2][2])/3;
            const sign = (nx*fcx+ny*fcy+nz*fcz) > 0 ? 1 : -1;
            const nn = [sign*nx/len, sign*ny/len, sign*nz/len];
            const base = p.length / 3;
            if (sign > 0) {
                p.push(...tri[0],...tri[1],...tri[2]);
            } else {
                p.push(...tri[0],...tri[2],...tri[1]);
            }
            n.push(...nn,...nn,...nn);
            idx.push(base, base+1, base+2);
        });
    });
    const buf = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; };
    return { p: buf(new Float32Array(p), gl.ARRAY_BUFFER), n: buf(new Float32Array(n), gl.ARRAY_BUFFER),
        i: buf(new Uint16Array(idx), gl.ELEMENT_ARRAY_BUFFER), c: idx.length };
}
// 0=Cube, 1=Cylinder, 2=Dodecahedron, 3=Sphere, 4=Tetrahedron, 5=StellatedOcta, 6=Cross, 7=GreatIcosa
const meshes = [makeCube(0.25), makeCylinder(0.1, 0.125, 16), makeDodecahedron(0.25), makeSphere(0.125, 12, 16), makeTetrahedron(0.25), makeStellatedOcta(0.25), makeCross(0.25), makeGreatIcosa(0.25)];

// ── Matrix math (column-major) ──
function persp(fov, asp, n, f) { const t = 1 / Math.tan(fov / 2), nf = 1 / (n - f); return new Float32Array([t / asp,0,0,0, 0,t,0,0, 0,0,(f + n) * nf,-1, 0,0,2 * f * n * nf,0]); }
function m4(a, b) { const o = new Float32Array(16); for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) for (let k = 0; k < 4; k++) o[j*4+i] += a[k*4+i] * b[j*4+k]; return o; }
function rX(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); }
function rY(a) { const c = Math.cos(a), s = Math.sin(a); return new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); }
function tr(x, y, z) { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }
function nm3(m) { return new Float32Array([m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]); }
function xfm(m, x, y, z) { return [m[0]*x + m[4]*y + m[8]*z, m[1]*x + m[5]*y + m[9]*z, m[2]*x + m[6]*y + m[10]*z]; }

// ── Game ──
const TR = 1.0, Tr = 0.4, CUBE_H = 0.125, CSPD = 6;
let score = 0, nextType = 0, nextShape = 0, fireMode = -1;
const SHAPES = ['Cube','Cylinder','Dodeca','Sphere','Tetra','Stella','Cross','Gt.Icosa'];
const cubes = [], stuckCubes = [], carves = [];

// FPS walker state
let fpsTheta = 0;    // major angle (around ring)
let fpsPhi = Math.PI / 2;  // minor angle (around tube), start at top
const fpsKeys = { w: false, a: false, s: false, d: false };
let fpsYaw = 0, fpsPitch = 0;

function fire() {
    if (cubes.length > 50) return;
    const type = fireMode >= 0 ? fireMode : nextType;
    if (fireMode < 0) nextType = (nextType + 1) % 3;
    const shape = nextShape; nextShape = (nextShape + 1) % 8;
    nsEl.textContent = SHAPES[nextShape];
    cubes.push({
        x: 0, y: 0, z: 6,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        vz: -CSPD,
        bouncing: false, passed: false, throughHole: false,
        type, shape, spin: Math.random() * 6.28
    });
}
function setFireMode(mode) {
    fireMode = mode;
    document.querySelectorAll('#picker span').forEach(s =>
        s.classList.toggle('active', +s.dataset.mode === mode));
}
document.querySelectorAll('#picker span').forEach(s =>
    s.addEventListener('click', () => setFireMode(+s.dataset.mode)));
addEventListener('keydown', e => {
    if (e.code === 'Space') { e.preventDefault(); fire(); }
    else if (e.key === '1') setFireMode(-1);
    else if (e.key === '2') setFireMode(0);
    else if (e.key === '3') setFireMode(1);
    else if (e.key === '4') setFireMode(2);
    if ('wasd'.includes(e.key)) fpsKeys[e.key] = true;
});
addEventListener('keyup', e => { if ('wasd'.includes(e.key)) fpsKeys[e.key] = false; });
canvas.addEventListener('click', e => {
    if (document.pointerLockElement !== canvas) {
        const rect = canvas.getBoundingClientRect();
        if (e.clientX - rect.left > rect.width / 2) canvas.requestPointerLock();
    }
    fire();
});
canvas.addEventListener('touchstart', e => { e.preventDefault(); fire(); });
document.addEventListener('mousemove', e => {
    if (document.pointerLockElement === canvas) {
        const sens = 0.003;
        fpsYaw += e.movementX * sens;
        fpsPitch -= e.movementY * sens;
        fpsPitch = Math.max(-1.4, Math.min(1.4, fpsPitch));
    }
});

function torusSDF(px, py, pz) { const q = Math.sqrt(px * px + py * py) - TR; return Math.sqrt(q * q + pz * pz) - Tr; }

function sdfNormal(x, y, z) {
    const e = 0.01;
    const gx = torusSDF(x + e, y, z) - torusSDF(x - e, y, z);
    const gy = torusSDF(x, y + e, z) - torusSDF(x, y - e, z);
    const gz = torusSDF(x, y, z + e) - torusSDF(x, y, z - e);
    const len = Math.sqrt(gx * gx + gy * gy + gz * gz) || 1;
    return [gx / len, gy / len, gz / len];
}

let msgTimer = 0;
function showMsg(txt, col) {
    msgEl.textContent = txt; msgEl.style.color = col; msgEl.style.opacity = 1;
    clearTimeout(msgTimer); msgTimer = setTimeout(() => msgEl.style.opacity = 0, 500);
}

// ── Render ──
gl.enable(gl.DEPTH_TEST);

const rmAP = gl.getAttribLocation(rmProg, 'aPos');
const mAP = gl.getAttribLocation(meshProg, 'aPos');
const mAN = gl.getAttribLocation(meshProg, 'aNorm');

function drawScene(vx, vw, camPos3, camMat3, invRot3, viewMat, asp) {
    gl.viewport(vx, 0, vw, canvas.height);
    gl.scissor(vx, 0, vw, canvas.height);

    const proj = persp(Math.PI / 4, asp, 0.1, 100);

    // ── Pass 1: Raymarched torus (solid CSG) ──
    gl.useProgram(rmProg);
    gl.disable(gl.CULL_FACE);
    gl.depthFunc(gl.LESS);

    gl.uniform1f(rmU('uAsp'), asp);
    gl.uniform1f(rmU('uTanFov'), Math.tan(Math.PI / 8));
    gl.uniformMatrix3fv(rmU('uInvRot'), false, invRot3);
    gl.uniform3fv(rmU('uCamPos'), camPos3);
    gl.uniformMatrix3fv(rmU('uCamMat'), false, camMat3);

    const cd = new Float32Array(MC * 4);
    for (let i = 0; i < carves.length; i++) { cd[i*4] = carves[i].lx; cd[i*4+1] = carves[i].ly; cd[i*4+2] = carves[i].lz; cd[i*4+3] = carves[i].shape; }
    gl.uniform4fv(rmU('uCarves[0]'), cd);
    gl.uniform1i(rmU('uNCrv'), carves.length);

    const sd = new Float32Array(MS * 4);
    for (let i = 0; i < stuckCubes.length; i++) { sd[i*4] = stuckCubes[i].lx; sd[i*4+1] = stuckCubes[i].ly; sd[i*4+2] = stuckCubes[i].lz; sd[i*4+3] = stuckCubes[i].shape; }
    gl.uniform4fv(rmU('uStuck[0]'), sd);
    gl.uniform1i(rmU('uNStk'), stuckCubes.length);

    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.enableVertexAttribArray(rmAP);
    gl.vertexAttribPointer(rmAP, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(rmAP);

    // ── Pass 2: Flying cubes (mesh) ──
    gl.useProgram(meshProg);
    gl.disable(gl.CULL_FACE);
    gl.uniformMatrix4fv(mU('uProj'), false, proj);

    for (const c of cubes) {
        let cm = m4(viewMat, tr(c.x, c.y, c.z));
        cm = m4(cm, rX(c.spin)); cm = m4(cm, rY(c.spin * 1.3));
        gl.uniformMatrix4fv(mU('uMV'), false, cm);
        gl.uniformMatrix3fv(mU('uNMat'), false, nm3(cm));
        if (c.type === 0) gl.uniform4f(mU('uTint'), 0.9, 0.15, 0.1, 1);
        else if (c.type === 2) gl.uniform4f(mU('uTint'), 0.2, 0.4, 1.0, 1);
        else gl.uniform4f(mU('uTint'), c.bouncing ? 0.5 : 0.15, c.bouncing ? 0.9 : 0.8, 0.2, 1);

        const mesh = meshes[c.shape];
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.p);
        gl.enableVertexAttribArray(mAP);
        gl.vertexAttribPointer(mAP, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.n);
        gl.enableVertexAttribArray(mAN);
        gl.vertexAttribPointer(mAN, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.i);
        gl.drawElements(gl.TRIANGLES, mesh.c, gl.UNSIGNED_SHORT, 0);
    }
    gl.disableVertexAttribArray(mAP);
    gl.disableVertexAttribArray(mAN);
}

let prev = 0;
function frame(t) {
    t *= 0.001; const dt = Math.min(t - prev, 0.05); prev = t;

    const tAX = t * 0.7, tAY = t * 1.1;
    const invRot = m4(rY(-tAY), rX(-tAX));
    const fwdRot = m4(rX(tAX), rY(tAY));

    // Update cubes
    for (let i = cubes.length - 1; i >= 0; i--) {
        const c = cubes[i];
        c.x += c.vx * dt; c.y += c.vy * dt; c.z += c.vz * dt;
        c.spin += dt * (c.bouncing ? 14 : 5);
        if (c.bouncing) c.vy -= 5 * dt;

        if (!c.bouncing && !c.passed) {
            const [lx, ly, lz] = xfm(invRot, c.x, c.y, c.z);
            const sdf = torusSDF(lx, ly, lz);
            const dAxis = Math.sqrt(lx * lx + ly * ly);
            if (dAxis < TR - Tr - CUBE_H && Math.abs(lz) < Tr + CUBE_H) c.throughHole = true;

            if (sdf < CUBE_H) {
                if (c.type === 0) {
                    stuckCubes.push({ lx, ly, lz, shape: c.shape, spin: c.spin });
                    if (stuckCubes.length > MS) stuckCubes.shift();
                    cubes.splice(i, 1); showMsg('STUCK!', '#ff6644'); continue;
                }
                if (c.type === 2) {
                    carves.push({ lx, ly, lz, shape: c.shape });
                    if (carves.length > MC) carves.shift();
                    for (let j = stuckCubes.length - 1; j >= 0; j--) {
                        const dx = stuckCubes[j].lx - lx, dy = stuckCubes[j].ly - ly, dz = stuckCubes[j].lz - lz;
                        if (Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz)) < 0.2) stuckCubes.splice(j, 1);
                    }
                    cubes.splice(i, 1); showMsg('CARVED!', '#4488ff'); continue;
                }
                c.bouncing = true;
                const [nx, ny, nz] = sdfNormal(lx, ly, lz);
                const [wnx, wny, wnz] = xfm(fwdRot, nx, ny, nz);
                const dot = c.vx * wnx + c.vy * wny + c.vz * wnz;
                c.vx = (c.vx - 2 * dot * wnx) * 0.5; c.vy = (c.vy - 2 * dot * wny) * 0.5; c.vz = (c.vz - 2 * dot * wnz) * 0.5;
                c.x += wnx * 0.2; c.y += wny * 0.2; c.z += wnz * 0.2;
                showMsg('BONK!', '#66ff44');
            }
        }

        if (!c.bouncing && !c.passed && c.z < -(TR + Tr + 0.5)) {
            c.passed = true;
            if (c.throughHole) { score++; scEl.textContent = score; showMsg('SCORE!', '#44ff44'); }
        }
        if (c.z > 12 || c.z < -12 || Math.abs(c.x) > 10 || Math.abs(c.y) > 10) cubes.splice(i, 1);
    }

    // Clear full framebuffer
    gl.enable(gl.SCISSOR_TEST);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.scissor(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.0, 0.2, 0.4, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const halfW = canvas.width / 2;
    const asp = halfW / canvas.height;
    const invRot3 = nm3(invRot);

    // ── Update walker position from WASD (relative to yaw direction) ──
    const fpsSpd = 2.0;
    const cY = Math.cos(fpsYaw), sY = Math.sin(fpsYaw);
    if (fpsKeys.w) { fpsTheta += cY * fpsSpd * dt; fpsPhi -= sY * fpsSpd * dt; }
    if (fpsKeys.s) { fpsTheta -= cY * fpsSpd * dt; fpsPhi += sY * fpsSpd * dt; }
    if (fpsKeys.a) { fpsTheta += sY * fpsSpd * dt; fpsPhi += cY * fpsSpd * dt; }
    if (fpsKeys.d) { fpsTheta -= sY * fpsSpd * dt; fpsPhi -= cY * fpsSpd * dt; }

    // Torus parametric position and frame
    const R = 1.0, r = 0.4, h = 0.15;
    const cT = Math.cos(fpsTheta), sT = Math.sin(fpsTheta);
    const cP = Math.cos(fpsPhi), sP = Math.sin(fpsPhi);

    // Surface point
    const sx = (R + r * cP) * cT;
    const sy = (R + r * cP) * sT;
    const sz = r * sP;

    // Outward normal
    const nx = cP * cT, ny = cP * sT, nz = sP;

    // Eye = surface + h * normal
    const ex = sx + h * nx, ey = sy + h * ny, ez = sz + h * nz;

    // Forward tangent (along ring)
    const fx = -sT, fy = cT, fz = 0;

    // Right = cross(forward, normal), then normalize
    let rx = fy * nz - fz * ny;
    let ry = fz * nx - fx * nz;
    let rz = fx * ny - fy * nx;
    const rl = Math.sqrt(rx * rx + ry * ry + rz * rz) || 1;
    rx /= rl; ry /= rl; rz /= rl;

    // Up = normal (already unit)
    const ux = nx, uy = ny, uz = nz;

    // Apply yaw (rotate forward/right around normal)
    const cYaw = Math.cos(fpsYaw), sYaw = Math.sin(fpsYaw);
    const lfx = cYaw*fx + sYaw*rx, lfy = cYaw*fy + sYaw*ry, lfz = cYaw*fz + sYaw*rz;
    const lrx = -sYaw*fx + cYaw*rx, lry = -sYaw*fy + cYaw*ry, lrz = -sYaw*fz + cYaw*rz;
    // Apply pitch (rotate forward/up around right)
    const cPit = Math.cos(fpsPitch), sPit = Math.sin(fpsPitch);
    const cfx = cPit*lfx + sPit*ux, cfy = cPit*lfy + sPit*uy, cfz = cPit*lfz + sPit*uz;
    const cux = -sPit*lfx + cPit*ux, cuy = -sPit*lfy + cPit*uy, cuz = -sPit*lfz + cPit*uz;

    // ── Left half: Exterior view ──
    const extPos = xfm(invRot, 0, 0, 7);
    drawScene(0, halfW, new Float32Array(extPos), invRot3, invRot3, tr(0, 0, -7), asp);

    // Draw walker marker on the exterior torus
    gl.viewport(0, 0, halfW, canvas.height);
    gl.scissor(0, 0, halfW, canvas.height);
    gl.useProgram(meshProg);
    const proj = persp(Math.PI / 4, asp, 0.1, 100);
    gl.uniformMatrix4fv(mU('uProj'), false, proj);
    const [wpx, wpy, wpz] = xfm(fwdRot, ex, ey, ez);
    const sc = 0.4;
    let wm = m4(tr(0, 0, -7), tr(wpx, wpy, wpz));
    wm = m4(wm, new Float32Array([sc,0,0,0, 0,sc,0,0, 0,0,sc,0, 0,0,0,1]));
    gl.uniformMatrix4fv(mU('uMV'), false, wm);
    gl.uniformMatrix3fv(mU('uNMat'), false, nm3(wm));
    gl.uniform4f(mU('uTint'), 1.0, 1.0, 0.0, 1);
    const markerMesh = meshes[3];
    gl.bindBuffer(gl.ARRAY_BUFFER, markerMesh.p);
    gl.enableVertexAttribArray(mAP);
    gl.vertexAttribPointer(mAP, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, markerMesh.n);
    gl.enableVertexAttribArray(mAN);
    gl.vertexAttribPointer(mAN, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, markerMesh.i);
    gl.drawElements(gl.TRIANGLES, markerMesh.c, gl.UNSIGNED_SHORT, 0);
    gl.disableVertexAttribArray(mAP);
    gl.disableVertexAttribArray(mAN);

    // ── Right half: FPS view ──
    // Camera mat3 for raymarcher: columns are [right, up, -forward]
    const fpsCamPos = new Float32Array([ex, ey, ez]);
    const fpsCamMat = new Float32Array([
        lrx, lry, lrz,
        cux, cuy, cuz,
        -cfx, -cfy, -cfz
    ]);

    // FPS view matrix for meshes (world space)
    // Transform local axes through fwdRot, then build R^T * T(-pos)
    const [cwx, cwy, cwz] = xfm(fwdRot, ex, ey, ez);
    const [rwx, rwy, rwz] = xfm(fwdRot, lrx, lry, lrz);
    const [uwx, uwy, uwz] = xfm(fwdRot, cux, cuy, cuz);
    const [fwx, fwy, fwz] = xfm(fwdRot, -cfx, -cfy, -cfz);
    const ftx = -(rwx*cwx + rwy*cwy + rwz*cwz);
    const fty = -(uwx*cwx + uwy*cwy + uwz*cwz);
    const ftz = -(fwx*cwx + fwy*cwy + fwz*cwz);
    const fpsView = new Float32Array([
        rwx, uwx, fwx, 0,
        rwy, uwy, fwy, 0,
        rwz, uwz, fwz, 0,
        ftx, fty, ftz, 1
    ]);

    drawScene(halfW, halfW, fpsCamPos, fpsCamMat, invRot3, fpsView, asp);

    gl.disable(gl.SCISSOR_TEST);
    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
