<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Voxel Cave</title>
<style>
  * { margin: 0; padding: 0; }
  body { overflow: hidden; background: #000; touch-action: none; }
  canvas { display: block; }
  #ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #ccc; font: 18px/1.8 system-ui, sans-serif; text-align: center;
    background: rgba(0,0,0,0.7); padding: 24px 36px; border-radius: 12px; }
  #ui h2 { color: #fff; margin-bottom: 4px; font-size: 24px; }
  #cross { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.5); font: 24px monospace; pointer-events: none; display: none;
    text-shadow: 0 0 4px rgba(0,0,0,0.8); }
</style>
</head>
<body>
<div id="ui">
  <h2>Voxel Cave</h2>
  Click to enter<br>
  WASD &mdash; move &nbsp;&bull;&nbsp; Mouse &mdash; look<br>
  Space / Shift &mdash; up / down<br>
  Left-click &mdash; carve (smooth spherical)
</div>
<div id="cross">+</div>

<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"}}</script>
<script type="module">
import * as THREE from 'three';

// ── Grid ───────────────────────────────────────────────────────────────
const GX = 48, GY = 32, GZ = 48;
const GX1 = GX + 1, GY1 = GY + 1, GZ1 = GZ + 1;
const density = new Float32Array(GX1 * GY1 * GZ1);
const DI = (x, y, z) => x + y * GX1 + z * GX1 * GY1;
const CI = (x, y, z) => x + y * GX + z * GX * GY;

// ── Noise ──────────────────────────────────────────────────────────────
function hash(x, y, z) {
  let n = Math.imul(x, 374761393) + Math.imul(y, 668265263) + Math.imul(z, 1274126177);
  n = Math.imul(n ^ (n >>> 13), 1274126177);
  return ((n ^ (n >>> 16)) & 0x7fffffff) / 0x7fffffff;
}
function smooth(x, y, z) {
  const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
  const fx = x - ix, fy = y - iy, fz = z - iz;
  const sx = fx*fx*(3-2*fx), sy = fy*fy*(3-2*fy), sz = fz*fz*(3-2*fz);
  const l = (a,b,t) => a + t*(b-a);
  return l(
    l(l(hash(ix,iy,iz),hash(ix+1,iy,iz),sx), l(hash(ix,iy+1,iz),hash(ix+1,iy+1,iz),sx), sy),
    l(l(hash(ix,iy,iz+1),hash(ix+1,iy,iz+1),sx), l(hash(ix,iy+1,iz+1),hash(ix+1,iy+1,iz+1),sx), sy),
    sz);
}
function fbm(x, y, z) {
  return (0.5*smooth(x,y,z) + 0.25*smooth(2*x,2*y,2*z)
        + 0.125*smooth(4*x,4*y,4*z) + 0.0625*smooth(8*x,8*y,8*z)) / 0.9375;
}

// ── Generate density field ─────────────────────────────────────────────
// density > 0 = solid rock, density <= 0 = air
const mx = GX / 2, my = GY / 2, mz = GZ / 2;
{
  const sc = 0.065;
  for (let z = 0; z <= GZ; z++)
  for (let y = 0; y <= GY; y++)
  for (let x = 0; x <= GX; x++) {
    if (x <= 1 || x >= GX-1 || y <= 1 || y >= GY-1 || z <= 1 || z >= GZ-1) {
      density[DI(x,y,z)] = 2.0; continue;
    }
    const n = fbm(x * sc, y * sc, z * sc);
    const dx = (x - mx) / mx, dy = (y - my) / my, dz = (z - mz) / mz;
    const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
    density[DI(x,y,z)] = (0.40 + d * 0.20) - n;
  }
  // guarantee air at spawn
  for (let dz = -4; dz <= 4; dz++)
  for (let dy = -4; dy <= 4; dy++)
  for (let dx = -4; dx <= 4; dx++) {
    if (dx*dx + dy*dy + dz*dz <= 14) {
      const gx = (mx + dx) | 0, gy = (my + dy) | 0, gz = (mz + dz) | 0;
      if (gx > 1 && gx < GX-1 && gy > 1 && gy < GY-1 && gz > 1 && gz < GZ-1)
        density[DI(gx, gy, gz)] = Math.min(density[DI(gx, gy, gz)], -0.5);
    }
  }
}

// ── Surface Nets mesh builder ──────────────────────────────────────────
const EDGES = [
  [0,1],[2,3],[4,5],[6,7],  // x-aligned
  [0,2],[1,3],[4,6],[5,7],  // y-aligned
  [0,4],[1,5],[2,6],[3,7],  // z-aligned
];

let caveMesh;
function buildMesh() {
  const cellIdx = new Int32Array(GX * GY * GZ).fill(-1);
  const vPos = [], vNrm = [], vCol = [];
  let nV = 0;

  // Phase 1: compute a vertex for each cell that straddles the isosurface
  for (let cz = 0; cz < GZ; cz++)
  for (let cy = 0; cy < GY; cy++)
  for (let cx = 0; cx < GX; cx++) {
    const d = [];
    for (let i = 0; i < 8; i++)
      d.push(density[DI(cx + (i & 1), cy + ((i >> 1) & 1), cz + ((i >> 2) & 1))]);
    let mask = 0;
    for (let i = 0; i < 8; i++) if (d[i] > 0) mask |= 1 << i;
    if (mask === 0 || mask === 255) continue;

    // average edge-crossing points
    let vx = 0, vy = 0, vz = 0, cnt = 0;
    for (const [a, b] of EDGES) {
      if ((d[a] > 0) !== (d[b] > 0)) {
        const t = d[a] / (d[a] - d[b]);
        vx += cx + (a & 1) + t * (((b & 1) - (a & 1)));
        vy += cy + ((a >> 1) & 1) + t * ((((b >> 1) & 1) - ((a >> 1) & 1)));
        vz += cz + ((a >> 2) & 1) + t * ((((b >> 2) & 1) - ((a >> 2) & 1)));
        cnt++;
      }
    }
    vx /= cnt; vy /= cnt; vz /= cnt;

    // normal from density gradient (points from solid toward air)
    const gx = (d[1]+d[3]+d[5]+d[7] - d[0]-d[2]-d[4]-d[6]) * 0.25;
    const gy = (d[2]+d[3]+d[6]+d[7] - d[0]-d[1]-d[4]-d[5]) * 0.25;
    const gz = (d[4]+d[5]+d[6]+d[7] - d[0]-d[1]-d[2]-d[3]) * 0.25;
    const len = Math.sqrt(gx*gx + gy*gy + gz*gz) || 1;

    // stone color from noise
    const v = hash(cx*7+31, cy*13+59, cz*19+97);
    const v2 = hash(cx*3+71, cy*11+23, cz*7+41);

    vPos.push(vx, vy, vz);
    vNrm.push(-gx/len, -gy/len, -gz/len);
    vCol.push(0.48 + v*0.14 + (v2-0.5)*0.06, 0.42 + v*0.11, 0.36 + v*0.08 + (v2-0.5)*0.04);
    cellIdx[CI(cx, cy, cz)] = nV++;
  }

  // Phase 2: emit quads for every grid edge that crosses the isosurface
  const indices = [];
  function quad(a, b, c, d) {
    if (a < 0 || b < 0 || c < 0 || d < 0) return;
    indices.push(a, b, c, a, c, d);
  }

  // X-edges: grid edge (x,y,z)→(x+1,y,z)
  for (let z = 1; z < GZ; z++)
  for (let y = 1; y < GY; y++)
  for (let x = 0; x < GX; x++) {
    const da = density[DI(x,y,z)], db = density[DI(x+1,y,z)];
    if ((da > 0) === (db > 0)) continue;
    const i0 = cellIdx[CI(x, y-1, z-1)], i1 = cellIdx[CI(x, y-1, z)];
    const i2 = cellIdx[CI(x, y,   z)],   i3 = cellIdx[CI(x, y,   z-1)];
    if (da > 0) quad(i0, i3, i2, i1); else quad(i0, i1, i2, i3);
  }
  // Y-edges: grid edge (x,y,z)→(x,y+1,z)
  for (let z = 1; z < GZ; z++)
  for (let y = 0; y < GY; y++)
  for (let x = 1; x < GX; x++) {
    const da = density[DI(x,y,z)], db = density[DI(x,y+1,z)];
    if ((da > 0) === (db > 0)) continue;
    const i0 = cellIdx[CI(x-1, y, z-1)], i1 = cellIdx[CI(x, y, z-1)];
    const i2 = cellIdx[CI(x,   y, z)],   i3 = cellIdx[CI(x-1, y, z)];
    if (da > 0) quad(i0, i3, i2, i1); else quad(i0, i1, i2, i3);
  }
  // Z-edges: grid edge (x,y,z)→(x,y,z+1)
  for (let z = 0; z < GZ; z++)
  for (let y = 1; y < GY; y++)
  for (let x = 1; x < GX; x++) {
    const da = density[DI(x,y,z)], db = density[DI(x,y,z+1)];
    if ((da > 0) === (db > 0)) continue;
    const i0 = cellIdx[CI(x-1, y-1, z)], i1 = cellIdx[CI(x, y-1, z)];
    const i2 = cellIdx[CI(x,   y,   z)], i3 = cellIdx[CI(x-1, y, z)];
    if (da > 0) quad(i0, i1, i2, i3); else quad(i0, i3, i2, i1);
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(vPos, 3));
  geo.setAttribute('normal', new THREE.Float32BufferAttribute(vNrm, 3));
  geo.setAttribute('color', new THREE.Float32BufferAttribute(vCol, 3));
  geo.setIndex(indices);

  if (caveMesh) { caveMesh.geometry.dispose(); scene.remove(caveMesh); }
  caveMesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ vertexColors: true }));
  scene.add(caveMesh);
}

// ── Scene ──────────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x060606);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x060606, 4, 32);
scene.add(new THREE.AmbientLight(0x404048));

const torch = new THREE.PointLight(0xffcc88, 3.5, 28, 1.2);
scene.add(torch);
const fill = new THREE.PointLight(0x445566, 1.2, 20, 1.5);
scene.add(fill);

// ── Colored ambient lights scattered through the cave ──────────────────
const caveLightColors = [
  0xffaa44, // warm amber
  0xffe066, // golden yellow
  0xcc8833, // deep amber
  0x4488cc, // steel blue
  0x3366bb, // deeper blue
  0x66aadd, // pale blue
  0x44bbcc, // teal
  0xffcc55, // yellow
  0x5577cc, // twilight blue
  0xddaa44, // ochre
];
const caveLights = [];
{
  // find air positions using a grid stride, place lights where density is well below 0
  const stride = 8;
  let colorIdx = 0;
  for (let gz = stride; gz < GZ - stride; gz += stride)
  for (let gy = stride; gy < GY - stride; gy += stride)
  for (let gx = stride; gx < GX - stride; gx += stride) {
    // check a small neighborhood is all air (so the light sits in open space)
    let minD = 0;
    for (let dz = -1; dz <= 1; dz++)
    for (let dy = -1; dy <= 1; dy++)
    for (let dx = -1; dx <= 1; dx++)
      minD = Math.min(minD, density[DI(gx+dx, gy+dy, gz+dz)]);
    if (minD > -0.15) continue; // not enough open air here

    const color = caveLightColors[colorIdx % caveLightColors.length];
    colorIdx++;
    const light = new THREE.PointLight(color, 2.0, 18, 1.5);
    light.position.set(gx, gy, gz);
    scene.add(light);
    caveLights.push(light);
  }
}

const cam = new THREE.PerspectiveCamera(80, innerWidth / innerHeight, 0.05, 60);
cam.position.set(mx, my, mz);

buildMesh();

// ── Controls ───────────────────────────────────────────────────────────
let yaw = 0, pitch = 0, locked = false;
const keys = {};

document.addEventListener('keydown', e => { keys[e.code] = true; });
document.addEventListener('keyup', e => { keys[e.code] = false; });

renderer.domElement.addEventListener('click', () => {
  if (!locked) renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', () => {
  locked = !!document.pointerLockElement;
  document.getElementById('ui').style.display = locked ? 'none' : 'block';
  document.getElementById('cross').style.display = locked ? 'block' : 'none';
});
document.addEventListener('mousemove', e => {
  if (!locked) return;
  yaw -= e.movementX * 0.002;
  pitch = Math.max(-1.55, Math.min(1.55, pitch - e.movementY * 0.002));
});

// ── Carving ────────────────────────────────────────────────────────────
function carve(px, py, pz, radius) {
  const r2 = radius * radius;
  const x0 = Math.max(2, Math.floor(px - radius));
  const x1 = Math.min(GX - 2, Math.ceil(px + radius));
  const y0 = Math.max(2, Math.floor(py - radius));
  const y1 = Math.min(GY - 2, Math.ceil(py + radius));
  const z0 = Math.max(2, Math.floor(pz - radius));
  const z1 = Math.min(GZ - 2, Math.ceil(pz + radius));
  for (let z = z0; z <= z1; z++)
  for (let y = y0; y <= y1; y++)
  for (let x = x0; x <= x1; x++) {
    const d2 = (x-px)**2 + (y-py)**2 + (z-pz)**2;
    if (d2 < r2) density[DI(x,y,z)] -= 0.6 * (1 - Math.sqrt(d2) / radius);
  }
}

const rc = new THREE.Raycaster();
rc.far = 8;
document.addEventListener('mousedown', e => {
  if (!locked || e.button !== 0) return;
  rc.setFromCamera({ x: 0, y: 0 }, cam);
  const hits = rc.intersectObject(caveMesh);
  if (!hits.length) return;
  const p = hits[0].point;
  carve(p.x, p.y, p.z, 2.0);
  buildMesh();
});

// ── Collision (trilinear density sampling) ─────────────────────────────
function densityAt(px, py, pz) {
  const ix = Math.floor(px), iy = Math.floor(py), iz = Math.floor(pz);
  if (ix < 0 || ix >= GX || iy < 0 || iy >= GY || iz < 0 || iz >= GZ) return 2;
  const fx = px - ix, fy = py - iy, fz = pz - iz;
  const l = (a, b, t) => a + t * (b - a);
  const d = (ox, oy, oz) => density[DI(ix+ox, iy+oy, iz+oz)];
  return l(l(l(d(0,0,0),d(1,0,0),fx), l(d(0,1,0),d(1,1,0),fx), fy),
           l(l(d(0,0,1),d(1,0,1),fx), l(d(0,1,1),d(1,1,1),fx), fy), fz);
}
function blocked(px, py, pz) {
  const R = 0.3;
  return densityAt(px-R,py,pz)>0 || densityAt(px+R,py,pz)>0 ||
         densityAt(px,py-R,pz)>0 || densityAt(px,py+R,pz)>0 ||
         densityAt(px,py,pz-R)>0 || densityAt(px,py,pz+R)>0;
}

// ── Resize ─────────────────────────────────────────────────────────────
addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  cam.aspect = innerWidth / innerHeight;
  cam.updateProjectionMatrix();
});

// ── Loop ───────────────────────────────────────────────────────────────
let prev = performance.now();
(function loop() {
  requestAnimationFrame(loop);
  const dt = Math.min((performance.now() - prev) / 1000, 0.1);
  prev = performance.now();

  cam.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));

  if (locked) {
    const spd = (keys.KeyR ? 12 : 5) * dt;
    const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(cam.quaternion);
    const rgt = new THREE.Vector3(1, 0, 0).applyQuaternion(cam.quaternion);
    const mv = new THREE.Vector3();
    if (keys.KeyW) mv.add(fwd);
    if (keys.KeyS) mv.sub(fwd);
    if (keys.KeyD) mv.add(rgt);
    if (keys.KeyA) mv.sub(rgt);
    if (keys.Space) mv.y += 1;
    if (keys.ShiftLeft || keys.ShiftRight) mv.y -= 1;
    if (mv.lengthSq() > 0) {
      mv.normalize().multiplyScalar(spd);
      const p = cam.position;
      if (!blocked(p.x + mv.x, p.y, p.z)) p.x += mv.x;
      if (!blocked(p.x, p.y + mv.y, p.z)) p.y += mv.y;
      if (!blocked(p.x, p.y, p.z + mv.z)) p.z += mv.z;
    }
  }

  torch.position.copy(cam.position);
  fill.position.copy(cam.position).add(new THREE.Vector3(0, 1, 0));
  renderer.render(scene, cam);
})();
</script>
</body>
</html>
